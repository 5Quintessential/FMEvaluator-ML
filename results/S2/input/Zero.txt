Zerocash: Decentralized Anonymous Payments from Bitcoin

(extended version)

Eli Ben-Sasson∗

Alessandro Chiesa†

Christina Garman‡

Matthew Green‡

Ian Miers‡

Eran Tromer§

Madars Virza†

May 18, 2014

Abstract

Bitcoin is the ﬁrst digital currency to see widespread adoption. Although payments are
conducted between pseudonyms, Bitcoin cannot oﬀer strong privacy guarantees: payment
transactions are recorded in a public decentralized ledger, from which much information can
be deduced. Zerocoin (Miers et al., IEEE S&P 2013) tackles some of these privacy issues by
unlinking transactions from the payment’s origin. Yet it still reveals payment destinations and
amounts, and is limited in functionality.

In this paper, we construct a full-ﬂedged ledger-based digital currency with strong privacy
guarantees. Our results leverage recent advances in zero-knowledge Succinct Non-interactive
ARguments of Knowledge (zk-SNARKs).

We formulate and construct decentralized anonymous payment schemes (DAP schemes). A
DAP scheme lets users pay each other directly and privately: the corresponding transaction
hides the payment’s origin, destination, and amount. We provide formal deﬁnitions and proofs
of the construction’s security.

We then build Zerocash, a practical instantiation of our DAP scheme construction.

In
Zerocash, transactions are less than 1 kB and take under 6 ms to verify — orders of magnitude
more eﬃcient than the less-anonymous Zerocoin and competitive with plain Bitcoin.

Keywords: Bitcoin, decentralized electronic cash, zero-knowledge proofs

∗Technion, eli@cs.technion.ac.il
†MIT, {alexch, madars}@mit.edu
‡Johns Hopkins University, {cgarman, imiers, mgreen}@cs.jhu.edu
§Tel Aviv University, tromer@cs.tau.ac.il

1

Contents

1 Introduction

3
4
zk-SNARKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1
5
1.2 Centralized anonymous payment systems
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
1.3 Decentralized anonymous payment schemes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
1.4 Zerocash . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.5 Paper organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

2 Background on zk-SNARKs

10
Informal deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1
11
2.2 Comparison with NIZKs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Known constructions and security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.4
zk-SNARK implementations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3 Deﬁnition of a decentralized anonymous payment scheme

13
3.1 Data structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2 Algorithms
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.3 Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.4 Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

4 Construction of a decentralized anonymous payment scheme

18
4.1 Cryptographic building blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
4.2
zk-SNARKs for pouring coins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.3 Algorithm constructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.4 Completeness and security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

5 Zerocash

20
5.1
Instantiation of building blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
5.2 Arithmetic circuit for pouring coins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

6 Integration with existing ledger-based currencies

26
Integration by replacing the base currency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
6.1
Integration by hybrid currency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
6.2
6.3 Extending the Bitcoin protocol to support the combined semantics . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
6.4 Additional anonymity considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

7 Experiments

28
7.1 Performance of zk-SNARKs for pouring coins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
7.2 Performance of Zerocash algorithms
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
7.3 Large-scale network simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

8 Optimizations and extensions

33
8.1 Everlasting anonymity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
8.2 Fast block propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
8.3

Improved storage requirements

9 Concurrent work

10 Conclusion

Acknowledgments

A Overview of Bitcoin and Zerocoin

38
A.1 Bitcoin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
A.2 Zerocoin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

B Completeness of DAP schemes

C Security of DAP schemes

40
41
C.1 Ledger indistinguishability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C.2 Transaction non-malleability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
C.3 Balance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

D Proof of Theorem 4.1

44
D.1 Proof of ledger indistinguishability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
D.2 Proof of transaction non-malleability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
51
D.3 Proof of balance

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

References

2

36

36

37

39

54

1

Introduction

Bitcoin is the ﬁrst digital currency to achieve widespread adoption. The currency owes its rise
in part to the fact that, unlike traditional e-cash schemes [Cha82, CHL05, ST99], it requires no
trusted parties. Instead of appointing a central bank, Bitcoin uses a distributed ledger known as the
block chain to store transactions carried out between users. Because the block chain is massively
replicated by mutually-distrustful peers, the information it contains is public.

While users may employ many identities (or pseudonyms) to enhance their privacy, an increasing
body of research shows that anyone can de-anonymize Bitcoin by using information in the block
chain [RM11, BBSU12, RS12, MPJ+13], such as the structure of the transaction graph as well as
the value and dates of transactions. As a result, Bitcoin fails to oﬀer even a modicum of the privacy
provided by traditional payment systems, let alone the robust privacy of anonymous e-cash schemes.
While Bitcoin is not anonymous itself, those with suﬃcient motivation can obfuscate their
transaction history with the help of mixes (also known as laundries or tumblers). A mix allows
users to entrust a set of coins to a pool operated by a central party and then, after some interval,
retrieve diﬀerent coins (with the same total value) from the pool. However, mixes suﬀer from
three limitations: (i) the delay to reclaim coins must be large to allow enough coins to be mixed
in; (ii) the mix operator can trace coins; and (iii) the mix operator may steal coins.1 For users
with “something to hide”, these risks may be acceptable. But typical legitimate users (1) wish to
keep their spending habits private from their peers, (2) are risk-averse and do not wish to expend
continual eﬀort in protecting their privacy, and (3) are often not suﬃciently aware that their privacy
has been compromised.

To protect their privacy, users thus need an instant, risk-free, and, most importantly, automatic
guarantee that data revealing their spending habits and account balances is not publicly accessible
by their neighbors, co-workers, and the merchants with whom they do business. Anonymous
transactions also ensure that the market value of a coin is independent of its history, thus ensuring
that legitimate users’ coins remain fungible.2
Zerocoin: a decentralized mix. Miers et al. [MGGR13] proposed Zerocoin, which extends
Bitcoin to provide strong anonymity guarantees. Like many e-cash protocols (e.g., [CHL05]),
Zerocoin employs zero-knowledge proofs to prevent transaction graph analyses. Unlike earlier
practical e-cash protocols, however, Zerocoin does not rely on digital signatures to validate coins,
nor does it require a central bank to prevent double spending. Instead, Zerocoin authenticates
coins by proving, in zero-knowledge, that they belong to a public list of valid coins (which can be
maintained on the block chain). Yet rather than a full-ﬂedged anonymous currency, Zerocoin is
a decentralized mix, where users may periodically “wash” their bitcoins via the Zerocoin protocol.
Routine day-to-day transactions must be conducted via Bitcoin, due to reasons that we now review.
The ﬁrst reason is performance. Redeeming zerocoins requires double-discrete-logarithm proofs
of knowledge, which have size that exceeds 45 kB and require 450 ms to verify (at the 128-bit
security level).3 These proofs must be broadcast through the network, veriﬁed by every node, and
permanently stored in the ledger. The entailed costs are higher, by orders of magnitude, than those
in Bitcoin and can seriously tax a Bitcoin network operating at normal scale.

1CoinJoin [Max13], an alternative proposal, replaces the central party of a mix with multi-signature transactions
that involve many collaborating Bitcoin users. CoinJoin can thus only mix small volumes of coins amongst users who
are currently online, is prone to denial-of-service attacks by third parties, and requires eﬀort to ﬁnd mixing partners.
2While the methods we detail in this paper accomplish this, the same techniques open the door for privacy-preserving

accountability and oversight (see Section 10).

3These published numbers [MGGR13] actually use a mix of parameters at both 128-bit and 80-bit security for

diﬀerent components of the construction. The cost is higher if all parameters are instantiated at 128-bit security.

3

The second reason is functionality. While Zerocoin constitutes a basic e-cash scheme, it lacks
critical features required of full-ﬂedged anonymous payments. First, Zerocoin uses coins of ﬁxed
denomination: it does not support payments of exact values, nor does it provide a means to give
change following a transaction (i.e., divide coins). Second, Zerocoin has no mechanism for one
user to pay another one directly in “zerocoins”. And third, while Zerocoin provides anonymity
by unlinking a payment transaction from its origin address, it does not hide the amount or other
metadata about transactions occurring on the network.

Our contribution. Addressing this challenge, this work oﬀers two main contributions.

(1) We introduce the notion of a decentralized anonymous payment scheme, which formally captures
the functionality and security guarantees of a full-ﬂedged decentralized electronic currency with
strong anonymity guarantees. We provide a construction of this primitive and prove its security
under speciﬁc cryptographic assumptions. The construction leverages recent advances in the area of
zero-knowledge proofs. Speciﬁcally, it uses zero-knowledge Succinct Non-interactive ARguments of
Knowledge (zk-SNARKs) [Gro10, Lip12, BCI+13, GGPR13, PGHR13, BCG+13, Lip13, BCTV14].

(2) We implement the above primitive, via a system that we call Zerocash. Our system (at 128
bits of security):
• reduces the size of transactions spending a coin to under 1 kB (an improvement of over 97.7%);
• reduces the spend-transaction veriﬁcation time to under 6 ms (an improvement of over 98.6%);
• allows for anonymous transactions of variable amounts;
• hides transaction amounts and the values of coins held by users; and
• allows for payments to be made directly to a user’s ﬁxed address (without user interaction).

To validate our system, we measured its performance and established feasibility by conducting
experiments in a test network of 1000 nodes (approximately 1
16 of the unique IPs in the Bitcoin
network and 1
3 of the nodes reachable at any given time [DW13]). This inspires conﬁdence that
Zerocash can be deployed as a fork of Bitcoin and operate at the same scale. Thus, due to its
substantially improved functionality and performance, Zerocash makes it possible to entirely replace
traditional Bitcoin payments with anonymous alternatives.

Concurrent work. The idea of using zk-SNARKs in the Bitcoin setting was ﬁrst presented by one
of the authors at Bitcoin 2013 [Ben13]. In concurrent work, Danezis et al. [DFKP13] suggest using
zk-SNARKs to reduce proof size and veriﬁcation time in Zerocoin; see Section 9 for a comparison.

1.1 zk-SNARKs

A zk-SNARK is an eﬃcient variant of a zero-knowledge proof of knowledge [GMR89], which we ﬁrst
informally describe via an example. Suppose Alice wishes to prove to Bob the statement “I (Alice)
own 30 bitcoins”. A simple method for Alice to do so is to point to 30 coins on the block chain and,
for each of them, sign a message (“hello, world”) using the secret key that controls that coin. Alas,
this method leaks knowledge to Bob, by identifying which coins are Alice’s. A zero-knowledge proof
of knowledge allows Alice to achieve the same goal, while revealing no information to Bob (beyond
the fact that she knows some secret keys that control 30 coins). Crucially, such proofs can be
obtained for any statement that can be veriﬁed to be true by use of an eﬃcient computation involving
auxiliary inputs such as trapdoors and passwords (such statements are called “NP statements”).

We now sketch in more technical terms the deﬁnition of a zk-SNARK; see Section 2 for more
details. A zk-SNARK is a non-interactive zero-knowledge proof of knowledge that is succinct, i.e.,
for which proofs are very short and easy to verify. More precisely, let L be an NP language, and let
C be a nondeterministic decision circuit for L on a given instance size n. A zk-SNARK can be used

4

to prove and verify membership in L, for instances of size n, as follows. After taking C as input, a
trusted party conducts a one-time setup phase that results in two public keys: a proving key pk
and a veriﬁcation key vk. The proving key pk enables any (untrusted) prover to produce a proof π
attesting to the fact that x ∈ L, for an instance x (of size n) of his choice. The non-interactive proof
π is zero knowledge and a proof of knowledge. Anyone can use the veriﬁcation key vk to verify the
proof π; in particular zk-SNARK proofs are publicly veriﬁable: anyone can verify π, without ever
having to interact with the prover who generated π. Succinctness requires that (for a given security
level) π has constant size and can be veriﬁed in time that is linear in |x| (rather than linear in |C|).

1.2 Centralized anonymous payment systems

Before describing our new decentralized payment system, we put it in context by recalling two
pre-Bitcoin payment schemes, both of which relied on a bank, acting as a central trusted party.

Anonymous e-cash. Chaum [Cha82] ﬁrst obtained anonymous e-cash. In Chaum’s scheme, the
minting of a coin involves both a user, Alice, and the bank: to mint a coin of a given value v, Alice
ﬁrst selects a random secret serial number sn (unknown to the bank); then, the bank, after deducting
v from Alice’s balance, signs sn via a blind signature. Afterwards, if Alice wants to transfer her coin
to Bob, she reveals sn to him and proves that sn was signed by the bank; during this transfer, Bob
(or the bank) cannot deduce Alice’s identity from the revealed information. Double-spending is
prevented because the bank will not honor a coin with a previously-seen serial number.

Unforgeable e-cash. One problem with Chaum’s scheme is that coins can be forged if the bank’s
secret key is compromised. Sander and Ta-Shma [ST99] addressed this, as follows. The bank
maintains a public Merkle tree of “coin commitments”, and users periodically retrieve its root rt; in
particular, the bank maintains no secrets. When Alice requests a coin (of unit value), she picks
a random serial number sn and auxiliary string r, and then sends cm := CRH(sn(cid:107)r) to the bank,
where CRH is a collision-resistant hash; the bank deducts the appropriate amount from Alice’s
balance and then records cm as a leaf in the Merkle tree. Afterwards, to pay Bob, Alice sends him
sn along with a zero-knowledge proof of knowledge π of the following NP statement: “there exists
r such that CRH(sn(cid:107)r) is a leaf in a Merkle tree with root rt”. In other words, Alice can convince
Bob that sn is the serial number contained in some coin commitment in the Merkle tree; but the
zero-knowledge property prevents Bob from learning information about which coin commitment is
Alice’s, thereby protecting Alice’s identity. Later, Bob can “cash out” Alice’s coin by showing sn
and π to the bank.4
Moving to a fungible anonymous decentralized system.
In this paper, like [ST99], we
hash a coin’s serial number and use Merkle trees to compactly represent the set of minted coins.
Unlike [ST99], we also ensure the privacy of a coin’s value and support transactions that split and
merge coins, thus achieving (and implementing) a new kind of fully-fungible and divisible payment
scheme. As in Bitcoin (and in stark contrast to previous e-cash schemes), we do not rely on a
trusted bank. Therefore, we require a new set of deﬁnitions and protocols, designed to protect
Alice’s anonymity while preventing her from falsely increasing her balance under the veil of her
boosted privacy. An informal description of our payment scheme follows.

1.3 Decentralized anonymous payment schemes

We construct a decentralized anonymous payment (DAP) scheme, which is a decentralized e-cash
scheme that allows direct anonymous payments of any amount. See Section 3 for a formal deﬁnition.

4We omit details about how the bank can identify Alice in the event that she double spends her coin.

5

Here, we outline our construction in six incremental steps; the construction details are in Section 4.
Our construction functions on top of any ledger-based base currency, such as Bitcoin. At any
given time, a unique valid snapshot of the currency’s ledger is available to all users. The ledger is a
sequence of transactions and is append-only. Transactions include both the underlying currency’s
transactions, as well as new transactions introduced by our construction. For concreteness, we focus
the discussion below on Bitcoin (though later deﬁnitions and constructions are stated abstractly). We
assume familiarity with Bitcoin [Nak09] and Zerocoin [MGGR13]; both are reviewed in Appendix A.

Step 1: user anonymity with ﬁxed-value coins. We ﬁrst describe a simpliﬁed construction,
in which all coins have the same value of, e.g., 1 BTC. This construction, similar to the Zerocoin
protocol, shows how to hide a payment’s origin. In terms of tools, we make use of zk-SNARKs
(recalled above) and a commitment scheme. Let COMM denote a statistically-hiding non-interactive
commitment scheme (i.e., given randomness r and message m, the commitment is c := COMMr(m);
subsequently, c is opened by revealing r and m, and one can verify that COMMr(m) equals c).

In the simpliﬁed construction, a new coin c is minted as follows: a user u samples a random
serial number sn and a trapdoor r, computes a coin commitment cm := COMMr(sn), and sets
c := (r, sn, cm). A corresponding mint transaction txMint, containing cm (but not sn or r), is sent to
the ledger; txMint is appended to the ledger only if u has paid 1 BTC to a backing escrow pool (e.g.,
the 1 BTC may be paid via plaintext information encoded in txMint). Mint transactions are thus
certiﬁcates of deposit, deriving their value from the backing pool.

Subsequently, letting CMList denote the list of all coin commitments on the ledger, u may spend
c by posting a spend transaction txSpend that contains (i) the coin’s serial number sn; and (ii) a
zk-SNARK proof π of the NP statement “I know r such that COMMr(sn) appears in the list CMList
of coin commitments”. Assuming that sn does not already appear on the ledger (as part of a past
spend transaction), u can redeem the deposited amount of 1 BTC, which u can either keep, transfer
to someone else, or mint a new coin. (If sn does already appear on the ledger, this is considered
double spending, and the transaction is discarded.)

User anonymity is achieved because the proof π is zero-knowledge: while sn is revealed, no
information about r is, and ﬁnding which of the numerous commitments in CMList corresponds
to a particular spend transaction txSpend is equivalent to inverting f (x) := COMMx(sn), which is
assumed to be infeasible. Thus, the origin of the payment is anonymous.

In the above NP statement, CMList is
Step 2: compressing the list of coin commitments.
speciﬁed explicitly as a list of coin commitments. This naive representation severely limits scalability
because the time and space complexity of most protocol algorithms (e.g., the proof veriﬁcation
algorithm) grow linearly with CMList. Moreover, coin commitments corresponding to already-spent
coins cannot be dropped from CMList to reduce costs, since they cannot be identiﬁed (due to the
same zero-knowledge property that provides anonymity).

As in [ST99], we rely on a collision-resistant function CRH to avoid an explicit representation
of CMList. We maintain an eﬃciently-updatable append-only CRH-based Merkle tree Tree(CMList)
over the (growing) list CMList and let rt denote the root of Tree(CMList). It is well-known that rt
can be updated to account for the insertion of new leaves with time and space proportional to just
the tree depth. Hence, the time and space complexity is reduced from linear in the size of CMList to
logarithmic. With this in mind, we modify the NP statement to the following one: “I know r such
that COMMr(sn) appears as a leaf in a CRH-based Merkle tree whose root is rt”. Compared with
the naive data structure for CMList, this modiﬁcation increases exponentially the size of CMList
that a given zk-SNARK implementation can support. (Concretely: using Merkle trees of depth 64,
Zerocash supports 264 coins.)
Step 3: extending coins for direct anonymous payments. So far, the coin commitment

6

cm of a coin c is a commitment to the coin’s serial number sn. However, this creates a problem
when transferring c to another user. Indeed, suppose that a user uA created c, and uA sends c to
another user uB. First, since uA knows sn, the spending of c by uB is both non-anonymous (since
uA sees when c is spent, by recognizing sn) and risky (since uA could still spend c ﬁrst). Thus, uB
must immediately spend c and mint a new coin c(cid:48) to protect himself. Second, if uA in fact wants
to transfer to uB, e.g., 100 BTC, then doing so is both unwieldy (since it requires 100 transfers)
and non-anonymous (since the amount of the transfer is leaked). And third, transfers in amounts
that are not multiples of 1 BTC (the ﬁxed value of a coin) are not supported. Thus, the simpliﬁed
construction described is inadequate as a payment scheme.

We address this by modifying the derivation of a coin commitment, and using pseudorandom
functions to target payments and to derive serial numbers, as follows. We use three pseudorandom
x (·), and
functions (derived from a single one). For a seed x, these are denoted PRFaddr
PRFpk

x (·). We assume that PRFsn is moreover collision-resistant.
To provide targets for payments, we use addresses: each user u generates an address key pair
(apk, ask), the address public key and address private key respectively. The coins of u contain the
value apk and can be spent only with knowledge of ask. A key pair (apk, ask) is sampled by selecting
a random seed ask and setting apk := PRFaddr
(0). A user can generate and use any number of
ask
address key pairs.

(·), PRFsn

x

Next, we redesign minting to allow for greater functionality. To mint a coin c of a desired
value v, the user u ﬁrst samples ρ, which is a secret value that determines the coin’s serial number
as sn := PRFsn
(ρ). Then, u commits to the tuple (apk, v, ρ) in two phases: (a) u computes
ask
k := COMMr(apk(cid:107)ρ) for a random r; and then (b) u computes cm := COMMs(v(cid:107)k) for a random s.
The minting results in a coin c := (apk, v, ρ, r, s, cm) and a mint transaction txMint := (v, k, s, cm).
Crucially, due to the nested commitment, anyone can verify that cm in txMint is a coin commitment
of a coin of value v (by checking that COMMs(v(cid:107)k) equals cm) but cannot discern the owner (by
learning the address key apk) or serial number (derived from ρ) because these are hidden in k. As
before, txMint is accepted by the ledger only if u deposits the correct amount, in this case v BTC.
Coins are spent using the pour operation, which takes a set of input coins, to be consumed, and
“pours” their value into a set of fresh output coins — such that the total value of output coins equals
the total value of the input coins. Suppose that u, with address key pair (aold
sk ), wishes to consume
and cnew
his coin cold = (aold
, with total
value vnew
pk,2. (The addresses
pk,2 may belong to u or to some other user.) The user u, for each i ∈ {1, 2}, proceeds as
anew
pk,1 and anew
pk,i(cid:107)ρnew
(anew
follows: (i) u samples serial number randomness ρnew
)
for a random rnew
.
pk,2, vnew

pk , aold
pk , vold, ρold, rold, sold, cmold) and produce two new coins cnew

, ρnew
,
). Next, u produces a zk-SNARK proof πPOUR for the following NP statement, which

; (ii) u computes knew
(cid:107)knew
i
) and cnew

2 = vold, respectively targeted at address public keys anew

This yields the coins cnew
, snew

; and (iii) u computes cmnew

:= COMMsnew
, snew

) for a random snew

pk,1 and anew

i
pk,1, vnew

(vnew
, cmnew

:= COMMrnew

1 + vnew

:= (anew

:= (anew

, cmnew

, ρnew

, rnew

1

2

1

1

1

1

1

2

2

1

2

i

i

i

i

i

i

i

i

rnew
2
we call POUR:

2

2

2

1

, cnew

, and address secret key aold

COMMsold(vold(cid:107)kold); and similarly for cnew

“Given the Merkle-tree root rt, serial number snold, and coin commitments cmnew
know coins cold, cnew
• The coins are well-formed: for cold it holds that kold = COMMrold(aold
and cnew
• The address secret key matches the public key: aold
• The serial number is computed correctly: snold := PRFsn
• The coin commitment cmold appears as a leaf of a Merkle-tree with root rt.
• The values add up: vnew

2
pk = PRFaddr
aold
sk
(ρold).

sk such that:

1 + vnew

2 = vold.”

(0).

aold
sk

.

1

1

, cmnew

, I
pk (cid:107)ρold) and cmold =

2

7

A resulting pour transaction txPour := (rt, snold, cmnew

, cmnew

2

1

, πPOUR) is appended to the ledger.

(As before, the transaction is rejected if the serial number sn appears in a previous transaction.)

pk,1. Then, u cannot spend cnew

Now suppose that u does not know, say, the address secret key anew

sk,1 that is associated with the
public key anew
because he cannot provide anew
sk,1 as part of the witness
of a subsequent pour operation. Furthermore, when a user who knows anew
sk,1 does spend cnew
, the
user u cannot track it, because he knows no information about its revealed serial number, which is
snnew

:= PRFsn

(ρnew

).

1

1

1

anew
sk,1

1

1

Then, u computes the ciphertext C1 that is the encryption of the plaintext (vnew

Also observe that txPour reveals no information about how the value of the consumed coin was
divided among the two new fresh coins, nor which coin commitment corresponds to the consumed
coin, nor the address public keys to which the two new fresh coins are targeted. The payment was
conducted in full anonymity.
More generally, a user may pour N old ≥ 0 coins into N new ≥ 0 coins. For simplicity we consider
the case N old = N new = 2, without loss of generality. Indeed, for N old < 2, the user can mint a coin
with value 0 and then provide it as a “null” input, and for N new < 2, the user can create (and discard)
a new coin with value 0. For N old > 2 or N new > 2, the user can compose log N old + log N new of
the 2-input/2-output pours.
Step 4: sending coins. Suppose that anew
pk,1 is the address public key of u1. In order to allow u1
to actually spend the new coin cnew
produced above, u must somehow send the secret values in
cnew
to u1. One way is for u to send u1 a private message, but the requisite private communication
1
channel necessitates additional infrastructure or assumptions. We avoid this “out-of-band” channel
and instead build this capability directly into our construction by leveraging the ledger as follows.
We modify the structure of an address key pair. Each user now has a key pair (addrpk, addrsk),
where addrpk = (apk, pkenc) and addrsk = (ask, skenc). The values (apk, ask) are generated as before.
In addition, (pkenc, skenc) is a key pair for a key-private encryption scheme [BBDP01].
, ρnew

, snew
),
under pknew
sk,1), and includes C1 in the pour
transaction txPour. The user u1 can then ﬁnd and decrypt this message (using his sknew
enc,1) by
scanning the pour transactions on the public ledger. Again, note that adding C1 to txPour leaks
neither paid amounts, nor target addresses due to the key-private property of the encryption scheme.
(The user u does the same with cnew
Step 5: public outputs. The construction so far allows users to mint, merge, and split coins.
But how can a user redeem one of his coins, i.e., convert it back to the base currency (Bitcoin)?
For this, we modify the pour operation to include a public output. When spending a coin, the user
u also speciﬁes a nonnegative vpub and a transaction string info ∈ {0, 1}∗. The balance equation
in the NP statement POUR is changed accordingly: “vnew
2 + vpub = vold”. Thus, of the input
value vold, a part vpub is publicly declared, and its target is speciﬁed, somehow, by the string info.
The string info can be used to specify the destination of these redeemed funds (e.g., a Bitcoin wallet
public key).5 Both vpub and info are now included in the resulting pour transaction txPour. (The
public output is optional, as the user u can set vpub = 0.)
Step 6: non-malleability. To prevent malleability attacks on a pour transaction txPour (e.g.,
embezzlement by re-targeting the public output of the pour by modifying info), we further modify
the NP statement POUR and use digital signatures. Speciﬁcally, during the pour operation, the user u
(i) samples a key pair (pksig, sksig) for a one-time signature scheme; (ii) computes hSig := CRH(pksig);
(iii) computes the two values h1 := PRFpk
(hSig), which act as MACs to
aold
sk,1

enc,1 (which is part of u1’s address public key addrnew

and includes a corresponding ciphertext C2 in txPour.)

(hSig) and h2 := PRFpk
aold
sk,2

1 + vnew

, rnew

2

1

1

1

1

5These public outputs can be considered as an “input” to a Bitcoin-style transaction, where the string info contains

the Bitcoin output scripts. This mechanism also allows us to support Bitcoin’s public transaction fees.

8

“tie” hSig to both address secret keys; (iv) modiﬁes POUR to include the three values hSig, h1, h2 and
prove that the latter two are computed correctly; and (v) uses sksig to sign every value associated
with the pour operation, thus obtaining a signature σ, which is included, along with pksig, in txPour.
Since the aold
sk,i are secret, and with high probability hSig changes for each pour transaction, the
values h1, h2 are unpredictable. Moreover, the signature on the NP statement (and other values)
binds all of these together, as argued in more detail in Appendix C and Appendix D.

This ends the outline of the construction, which is summarized in part in Figure 1. We conclude by
noting that, due to the zk-SNARK, our construction requires a one-time trusted setup of public
parameters. The soundness of the proofs depends on this trust, though anonymity continues to
hold even if the setup is corrupted by a malicious party.

Figure 1: (a) Illustration of the CRH-based Merkle tree over the list CMList of coin commitments. (b) A
coin c. (c) Illustration of the structure of a coin commitment cm. (d) Illustration of the structure of a
coin serial number sn.

1.4 Zerocash

We outline Zerocash, a concrete implementation, at 128 bits of security, of our DAP scheme
construction; see Section 5 for details. Zerocash entails carefully instantiating the cryptographic
ingredients of the construction to ensure that the zk-SNARK, the “heaviest” component, is eﬃcient
In the construction, the zk-SNARK is used to prove/verify a speciﬁc NP
enough in practice.
statement: POUR. While zk-SNARKs are asymptotically eﬃcient, their concrete eﬃciency depends
on the arithmetic circuit C that is used to decide the NP statement. Thus, we seek instantiations for
which we can design a relatively small arithmetic circuit CPOUR for verifying the NP statement POUR.
Our approach is to instantiate all of the necessary cryptographic ingredients (commitment
schemes, pseudorandom functions, and collision-resistant hashing) based on SHA256. We ﬁrst design
a hand-optimized circuit for verifying SHA256 computations (or, more precisely, its compression
function, which suﬃces for our purposes).6 Then, we use this circuit to construct CPOUR, which
veriﬁes all the necessary checks for satisfying the NP statement CPOUR.

This, along with judicious parameter choices, and a state-of-the-art implementation of a
zk-SNARK for arithmetic circuits [BCTV14] (see Section 2.4), results in a zk-SNARK prover

6Alternatively, we could have opted to rely on the circuit generators [PGHR13, BCG+13, BCTV14], which support
various classes of C programs, by writing C code expressing the POUR checks. However, as discussed later, these generic
approaches are more expensive than our hand-optimized construction.

9

… (c) coin commitmentrt(a) Merke tree over (cm1,cm2,…)cmCRHCRHCRHCRHCRHCRHCRHcm1cm2cm3cm4cm5cm6cm7cm8CRHCRHCRHCOMMvρ(cid:2)(cid:4)(cid:3)PRFsnPRFaddrs(cid:2)(cid:5)(cid:3)COMMr(cid:2)(cid:5)(cid:3)sn(cid:1)(d) serial numberrt = Merkle-tree rootcm = coin commitmentsn = serial numberv = coin valuer, s = commitment rand.ρ = serial number rand.(apk,pkenc) = address public key(ask,skenc) = address secret keyc = ((apk,pkenc), v, ρ, r, s, cm)(b) coinrunning time of a few minutes and zk-SNARK veriﬁer running time of a few milliseconds. This
allows the DAP scheme implementation to be practical for deployment, as our experiments show.
Zerocash can be integrated into Bitcoin or forks of it (commonly referred to as “altcoins”); we

later describe how this is done.

1.5 Paper organization

The remainder of this paper is organized as follows. Section 2 provides background on zk-SNARKs.
We deﬁne DAP schemes in Section 3, and our construction thereof in Section 4. Section 5 discusses
the concrete instantiation in Zerocash. Section 6 describes the integration of Zerocash into existing
ledger-based currencies. Section 7 provides microbenchmarks for our prototype implementation, as
well as results based on full-network simulations. Section 8 describes optimizations. We discuss
concurrent work in Section 9 and summarize our contributions and future directions in Section 10.

2 Background on zk-SNARKs

The main cryptographic primitive used in this paper is a special kind of Succinct Non-interactive
ARgument of Knowledge (SNARK). Concretely, we use a publicly-veriﬁable preprocessing zero-
knowledge SNARK, or zk-SNARK for short.
In this section we provide basic background on
zk-SNARKs, provide an informal deﬁnition, compare zk-SNARKs with the more familiar notion of
NIZKs, and recall known constructions and implementations.

2.1 Informal deﬁnition

We informally deﬁne zk-SNARKs for arithmetic circuit satisﬁability. We refer the reader to,
e.g., [BCI+13] for a formal deﬁnition.

For a ﬁeld F, an F-arithmetic circuit takes inputs that are elements in F, and its gates output
elements in F. We naturally associate a circuit with the function it computes. To model nonde-
terminism we consider circuits that have an input x ∈ Fn and an auxiliary input a ∈ Fh, called
a witness. The circuits we consider only have bilinear gates.7 Arithmetic circuit satisﬁability is
deﬁned analogously to the boolean case, as follows.
Deﬁnition 2.1. The arithmetic circuit satisﬁability problem of an F-arithmetic circuit C : Fn ×
Fh → Fl is captured by the relation RC = {(x, a) ∈ Fn × Fh : C(x, a) = 0l}; its language is
LC = {x ∈ Fn : ∃ a ∈ Fh s.t. C(x, a) = 0l}.

Given a ﬁeld F, a (publicly-veriﬁable preprocessing) zk-SNARK for F-arithmetic circuit

satisﬁability is a triple of polynomial-time algorithms (KeyGen, Prove, Verify):
• KeyGen(1λ, C) → (pk, vk). On input a security parameter λ (presented in unary) and an F-
arithmetic circuit C, the key generator KeyGen probabilistically samples a proving key pk and a
veriﬁcation key vk. Both keys are published as public parameters and can be used, any number
of times, to prove/verify membership in LC.

• Prove(pk, x, a) → π. On input a proving key pk and any (x, a) ∈ RC, the prover Prove outputs a

non-interactive proof π for the statement x ∈ LC.
7A gate with inputs y1, . . . , ym ∈ F is bilinear if the output is (cid:104)(cid:126)a, (1, y1, . . . , ym)(cid:105) · (cid:104)(cid:126)b, (1, y1, . . . , ym)(cid:105) for some

(cid:126)a,(cid:126)b ∈ Fm+1. These include addition, multiplication, negation, and constant gates.

10

• Verify(vk, x, π) → b. On input a veriﬁcation key vk, an input x, and a proof π, the veriﬁer Verify

outputs b = 1 if he is convinced that x ∈ LC.

A zk-SNARK satisﬁes the following properties.
Completeness. For every security parameter λ, any F-arithmetic circuit C, and any (x, a) ∈ RC,
the honest prover can convince the veriﬁer. Namely, b = 1 with probability 1 − negl(λ) in the
following experiment: (pk, vk) ← KeyGen(1λ, C); π ← Prove(pk, x, a); b ← Verify(vk, x, π).
Succinctness. An honestly-generated proof π has Oλ(1) bits and Verify(vk, x, π) runs in time Oλ(|x|).
(Here, Oλ hides a ﬁxed polynomial factor in λ.)
Proof of knowledge (and soundness).
If the veriﬁer accepts a proof output by a bounded
prover, then the prover “knows” a witness for the given instance. (In particular, soundness holds
against bounded provers.) Namely, for every poly(λ)-size adversary A, there is a poly(λ)-size
extractor E such that Verify(vk, x, π) = 1 and (x, a) (cid:54)∈ RC with probability negl(λ) in the following
experiment: (pk, vk) ← KeyGen(1λ, C); (x, π) ← A(pk, vk); a ← E(pk, vk).
Perfect zero knowledge. An honestly-generated proof is perfect zero knowledge.8 Namely, there
is a polynomial-time simulator Sim such that for all stateful distinguishers D the following two
probabilities are equal:

 (x, a) ∈ RC

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) (pk, vk) ← KeyGen(1λ, C)

D(π) = 1

(x, a) ← D(pk, vk)
π ← Prove(pk, x, a)
(the probability that D(π) = 1 on an honest proof)

Pr



 (x, a) ∈ RC

D(π) = 1

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) (pk, vk, trap) ← Sim(1λ, C)

(x, a) ← D(pk, vk)
π ← Sim(trap, x)

 .

and Pr

(the probability that D(π) = 1 on a simulated proof)

Remark. Both proof of knowledge and zero knowledge are essential to the use of zk-SNARKs in
this paper. Indeed, we consider circuits C that verify assertions about cryptographic primitives
(such as using a knowledge of SHA256 pre-image as a binding commitment). Thus it does not suﬃce
to merely know that, for a given input x, a witness for x ∈ LC exists. Instead, proof of knowledge
ensures that a witness can be eﬃciently found (by extracting it from the prover) whenever the
veriﬁer accepts a proof. As for zero knowledge, it ensures that a proof leaks no information about
the witness, beyond the fact that x ∈ LC.

Remark. In the security proofs (see Appendix D), we deal with provers producing a vector of inputs
(cid:126)x together with a vector of corresponding proofs (cid:126)π. In such cases, it is convenient to use an extractor
that can extract a vector of witnesses (cid:126)a containing a valid witness for each valid proof. This “multi-
instance” extraction follows from the “single-instance” one described above [BCCT12, BCCT13].
Namely, if (KeyGen, Prove, Verify) is a zk-SNARK, then for any poly(λ)-size prover adversary A
there exists a poly(λ)-size extractor E such that

 ∃ i s.t.

Pr

Verify(vk, xi, πi) = 1

(xi, ai) /∈ RC

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) (pk, vk) ← KeyGen(1λ, C)

((cid:126)x, (cid:126)π) ← A(pk, vk)
(cid:126)a ← E(pk, vk)

 ≤ negl(λ) .

2.2 Comparison with NIZKs

zk-SNARKs are related to a familiar cryptographic primitive: non-interactive zero-knowledge proofs
of knowledge (NIZKs). Both zk-SNARKs and NIZKs require a one-time trusted setup of public

8While most zk-SNARK descriptions in the literature only mention statistical zero knowledge, all zk-SNARK

constructions can be made perfect zero knowledge by allowing for a negligible error probability in completeness.

11

parameters (proving and veriﬁcation keys for zk-SNARKs, and a common reference string for
NIZKs). Both provide the same guarantees of completeness, proof of knowledge, and zero knowledge.
The diﬀerence lies in eﬃciency guarantees. In a NIZK, the proof length and veriﬁcation time depend
on the NP language being proved. For instance, for the language of circuit satisﬁability, the proof
length and veriﬁcation time in [GOS06b, GOS06a] are linear in the circuit size. Conversely, in a
zk-SNARK, proof length depends only on the security parameter, and veriﬁcation time depends
only on the instance size (and security parameter) but not on the circuit or witness size.

Thus, zk-SNARKs can be thought of as “succinct NIZKs”, having short proofs and fast veriﬁca-
tion times. Succinctness comes with a caveat: known zk-SNARK constructions rely on stronger
assumptions than NIZKs do (see below).

2.3 Known constructions and security

There are many zk-SNARK constructions in the literature [Gro10, Lip12, BCI+13, GGPR13,
PGHR13, BCG+13, Lip13, BCTV14]. We are interested in zk-SNARKs for arithmetic circuit
satisﬁability, and the most eﬃcient ones for this language are based on quadratic arithmetic
programs [GGPR13, BCI+13, PGHR13, BCG+13, BCTV14]; such constructions provide a linear-
time KeyGen, quasilinear-time Prove, and linear-time Verify.

Security of zk-SNARKs is based on knowledge-of-exponent assumptions and variants of Diﬃe–
Hellman assumptions in bilinear groups [Gro10, BB04, Gen04]. While knowledge-of-exponent
assumptions are fairly strong, there is evidence that such assumptions may be inherent for con-
structing zk-SNARKs [GW11, BCCT12].

Remark (fully-succinct zk-SNARKs). The key generator KeyGen takes a circuit C as input. Thus,
KeyGen’s running time is at least linear in the size of the circuit C. One could require KeyGen to not
have to take C as input, and have its output keys work for all (polynomial-size) circuits C. In such
a case, KeyGen’s running time would be independent of C. A zk-SNARK satisfying this stronger
property is fully succinct. Theoretical constructions of fully-succinct zk-SNARKs are known, based
on various cryptographic assumptions [Mic00, Val08, BCCT13]. Despite achieving essentially-optimal
asymptotics [BFLS91, BGH+05, BCGT13b, BCGT13a, BCCT13] no implementations of them have
been reported in the literature to date.

2.4 zk-SNARK implementations

There are three published implementations of zk-SNARKs: (i) Parno et al. [PGHR13] present
an implementation of zk-SNARKs for programs having no data dependencies;9 (ii) Ben-Sasson
et al. [BCG+13] present an implementation of zk-SNARKs for arbitrary programs (with data
dependencies); and (iii) Ben-Sasson et al. [BCTV14] present an implementation of zk-SNARKs
that supports programs that modify their own code (e.g., for runtime code generation); their
implementation also reduces costs for programs of larger size and allows for universal key pairs.

Each of the works above also achieves zk-SNARKs for arithmetic circuit satisﬁability as a
stepping stone towards their respective higher-level eﬀorts. In this paper we are only interested in
a zk-SNARK for arithmetic circuit satisﬁability, and we rely on the implementation of [BCTV14]
for such a zk-SNARK.10 The implementation in [BCTV14] is itself based on the protocol of Parno
et al. [PGHR13]. We thus refer the interested reader to [PGHR13] for details of the protocol, its

9They only support programs where array indices are restricted to be known compile-time constants; similarly,

loop iteration counts (or at least upper bounds to these) must be known at compile time.

10In [BCTV14], one optimization to the veriﬁer’s runtime requires preprocessing the veriﬁcation key vk; for simplicity,

we do not use this optimization.

12

intuition, and its proof of security; and to [BCTV14] for the implementation and its performance.
In terms of concrete parameters, the implementation of [BCTV14] provides 128 bits of security, and
the ﬁeld F is of a 256-bit prime order p.

3 Deﬁnition of a decentralized anonymous payment scheme

We introduce the notion of a decentralized anonymous payment scheme (DAP scheme), extending
the notion of decentralized e-cash [MGGR13]. Later, in Section 4, we provide a construction.

3.1 Data structures

between 0 and a maximum value vmax (which is a system parameter).

We begin by describing, and giving intuition about, the data structures used by a DAP scheme.
The algorithms that use and produce these data structures are introduced in Section 3.2.
Basecoin ledger. Our protocol is applied on top of a ledger-based base currency such as Bitcoin;
for generality we refer to this base currency as Basecoin. At any given time T , all users have access
to LT , the ledger at time T , which is a sequence of transactions. The ledger is append-only (i.e.,
T < T (cid:48) implies that LT is a preﬁx of LT (cid:48)).11 The transactions in the ledger include both Basecoin
transactions as well as two new transaction types described below.
Public parameters. A list of public parameters pp is available to all users in the system. These
are generated by a trusted party at the “start of time” and are used by the system’s algorithms.
Addresses. Each user generates at least one address key pair (addrpk, addrsk). The public key
addrpk is published and enables others to direct payments to the user. The secret key addrsk is used
to receive payments sent to addrpk. A user may generate any number of address key pairs.
Coins. A coin is a data object c, to which we associate the following.
• A coin commitment, denoted cm(c): a string that appears on the ledger once c is minted.
• A coin value, denoted v(c): the denomination of c, as measured in basecoins, as an integer
• A coin serial number, denoted sn(c): a unique string associated with c, used to prevent double
• A coin address, denoted addrpk(c): an address public key, representing who owns c.
Any other quantities associated with a coin c (e.g., various trapdoors) are implementation details.
New transactions. Besides Basecoin transactions, there are two new types of transactions.
• Mint transactions. A mint transaction txMint is a tuple (cm, v,∗), where cm is a coin commitment,
v is a coin value, and ∗ denotes other (implementation-dependent) information. The transaction
txMint records that a coin c with coin commitment cm and value v has been minted.
, vpub, info,∗),
, cmnew
, cmnew
where rt is a root of a Merkle tree, snold
are
two coin commitments, vpub is a coin value, info is an arbitrary string, and ∗ denotes other
(implementation-dependent) information. The transaction txPour records the pouring of two
input (and now consumed) coins cold
2 , into two
new output coins cnew
, as well as a public
output vpub (which may be zero). Furthermore, txPour also records an information string info
(perhaps containing information on who is the recipient of vpub basecoins) and that, when this
transaction was made, the root of the Merkle tree over coin commitments was rt (see below).

• Pour transactions. A pour transaction txPour is a tuple (rt, snold

2 , with respective serial numbers snold

, with respective coin commitments cmnew

are two coin serial numbers, cmnew

2 , cmnew

1 , snold

1 , snold

1 , snold
2

spending.

1 , cold

, cmnew

, cnew

1

2

1

1

2

1

2

2

11In reality, the Basecoin ledger (such as the one of Bitcoin) is not perfect and may incur temporary inconsistencies.
In this respect our construction is as good as the underlying ledger. We discuss the eﬀects of this on anonymity and
mitigations in Section 6.4.

13

Commitments of minted coins and serial numbers of spent coins. For any given time T ,
• CMListT denotes the list of all coin commitments appearing in mint and pour transactions in LT ;
• SNListT denotes the list of all serial numbers appearing in pour transactions in LT .
While both of these lists can be deduced from LT , it will be convenient to think about them as
separate (as, in practice, these may be separately maintained for eﬃciency reasons; cf. Section 8.3).
Merkle tree over commitments. For any given time T , TreeT denotes a Merkle tree over
CMListT and rtT its root. Moreover, the function PathT (cm) gives the authentication path from a
coin commitment cm appearing in CMListT to the root of TreeT .12 For convenience, we assume that
LT also stores rtT (cid:48) for all T (cid:48) ≤ T (i.e., it stores all past Merkle tree roots).

3.2 Algorithms

A DAP scheme Π is a tuple of polynomial-time algorithms

(Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive)

with the following syntax and semantics.

System setup. The algorithm Setup generates a list of public parameters:

Setup
• inputs: security parameter λ
• outputs: public parameters pp

The algorithm Setup is executed by a trusted party. The resulting public parameters pp are published
and made available to all parties (e.g., by embedding them into the protocol’s implementation). The
setup is done only once; afterwards, no trusted party is needed, and no global secrets or trapdoors
are kept.

Creating payment addresses. The algorithm CreateAddress generates a new address key pair:

CreateAddress
• inputs: public parameters pp
• outputs: address key pair (addrpk, addrsk)
Each user generates at least one address key pair (addrpk, addrsk) in order to receive coins. The
public key addrpk is published, while the secret key addrsk is used to redeem coins sent to addrpk. A
user may generate any number of address key pairs; doing so does not require any interaction.

Minting coins. The algorithm Mint generates a coin (of a given value) and a mint transaction:

Mint
• inputs:

– public parameters pp
– coin value v ∈ {0, 1, . . . , vmax}
– destination address public key addrpk

• outputs: coin c and mint transaction txMint
A system parameter, vmax, caps the value of any single coin. The output coin c has value v and
coin address addrpk; the output mint transaction txMint equals (cm, v,∗), where cm is the coin
commitment of c.

12While we refer to Mekle trees for simplicity, it is straightforward to extend the deﬁnition to allow other data

structures representing sets with fast insertion and eﬃcient proofs of membership.

14

Pouring coins. The Pour algorithm transfers value from input coins into new output coins,
marking the input coins as consumed. Moreover, a fraction of the input value may be publicly
revealed. Pouring allows users to subdivide coins into smaller denominations, merge coins, and
transfer ownership of anonymous coins, or make public payments.13

Pour
• inputs:

– public parameters pp
– the Merkle root rt
– old coins cold
1 , cold
2
– old addresses secret keys addrold
– authentication path path1 from commitment cm(cold
authentication path path2 from commitment cm(cold

sk,1, addrold
sk,2

1 ) to root rt,
2 ) to root rt

2

1

1

2

, cnew

, vnew

pk,1, addrnew
pk,2

and pour transaction txPour

– new values vnew
– new addresses public keys addrnew
– public value vpub
– transaction string info
• outputs: new coins cnew
Thus, the Pour algorithm takes as input two distinct input coins cold
2 , along with corresponding
address secret keys addrold
sk,2 (required to redeem the two input coins). To ensure that
cold
1 , cold
2 have been previously minted, the Pour algorithm also takes as input the Merkle root rt
(allegedly, equal to the root of Merkle tree over all coin commitments so far), along with two
1 ), cm(cold
authentication paths path1, path2 for the two coin commitments cm(cold
2 ). Two input values
vnew
to be generated, and two input
1
address public keys addrnew
. A third value, vpub, speciﬁes
the amount to be publicly spent (e.g., to redeem coins or pay transaction fees). The sum of output
values vnew
2 + vpub must be equal to the sum of the values of the input coins (and cannot
exceed vmax). Finally, the Pour algorithm also receives an arbitrary string info, which is bound into
the output pour transaction txPour.

2
pk,2 specify the recipients of cnew
, cnew

specify the values of two new anonymous coins cnew

pk,1, addrnew

sk,1, addrold

1 + vnew

1 , cold

, vnew

, cnew

2

1

1

2

The Pour algorithm outputs two new coins cnew

and a pour transaction txPour. The
transaction txPour equals (rt, snold
are the two
coin commitments of the two output coins, and ∗ denotes other (implementation-dependent)
information. Crucially, txPour reveals only one value, the public value vpub (which may be zero); it
does not reveal the payment addresses or values of the old or new coins.

, cnew
, vpub, info,∗), where cmnew

2 , cmnew

1
, cmnew

1 , snold

, cmnew

2

1

2

1

2

Verifying transactions. The algorithm VerifyTransaction checks the validity of a transaction:

VerifyTransaction
• inputs:

– public parameters pp
– a (mint or pour) transaction tx
– the current ledger L

• outputs: bit b, equals 1 iﬀ the transaction is valid

Both mint and pour transactions must be veriﬁed before being considered well-formed. In practice,
transactions can be veriﬁed by the nodes in the distributed system maintaining the ledger, as well

13We consider pours with 2 inputs and 2 outputs, for simplicity and (as discussed in Section 1.3) without loss of

generality.

15

as by users who rely on these transactions.
Receiving coins. The algorithm Receive scans the ledger and retrieves unspent coins paid to a
particular user address:

Receive
• inputs:

– recipient address key pair (addrpk, addrsk)
– the current ledger L

• outputs: set of (unspent) received coins

When a user with address key pair (addrpk, addrsk) wishes to receive payments sent to addrpk, he
uses the Receive algorithm to scan the ledger. For each payment to addrpk appearing in the ledger,
Receive outputs the corresponding coins whose serial numbers do not appear on the ledger L. Coins
received in this way may be spent, just like minted coins, using the Pour algorithm. (We only require
Receive to detect coins paid to addrpk via the Pour algorithm and not also detect coins minted by
the user himself.)

Next, we describe completeness (Section 3.3) and security (Section 3.4).

3.3 Completeness

Completeness of a DAP scheme requires that unspent coins can be spent. More precisely, consider a
ledger sampler S outputting a ledger L. If c1 and c2 are two coins whose coin commitments appear
in (valid) transactions on L, but their serial numbers do not appear in L, then c1 and c2 can be
spent using Pour. Namely, running Pour results in a pour transaction txPour that VerifyTransaction
accepts, and the new coins can be received by the intended recipients (by using Receive); moreover,
txPour correctly records the intended vpub and transaction string info. This property is formalized
via an incompleteness experiment INCOMP.

Deﬁnition 3.1. A DAP scheme Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive)
is complete if no polynomial-size ledger sampler S wins INCOMP with more than negligible
probability. (See Appendix B for details.)

3.4 Security

Security of a DAP scheme is characterized by three properties, which we call ledger indistinguishability,
transaction non-malleability, and balance.

Deﬁnition 3.2. A DAP scheme Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive)
is secure if it satisﬁes ledger indistinguishability, transaction non-malleability, and balance.

Below, we provide an informal overview of each property, and defer formal deﬁnitions to Appendix C.
Each property is formalized as a game between an adversary A and a challenger C. In each game,
the behavior of honest parties is realized via a DAP scheme oracle ODAP, which maintains a ledger L
and provides an interface for executing CreateAddress, Mint, Pour and Receive algorithms for honest
parties. To elicit behavior from honest parties, A passes a query to C, which (after sanity checks)
proxies the query to ODAP. For each query that requests an honest party to perform an action, A
speciﬁes identities of previous transactions and the input values, and learns the resulting transaction,
but not any of the secrets or trapdoors involved in producing that transaction. The oracle ODAP
also provides an Insert query that allows A to directly add aribtrary transactions to the ledger L.

16

0

0

1

1

Ledger indistinguishability. This property captures the requirement that the ledger reveals no
new information to the adversary beyond the publicly-revealed information (values of minted coins,
public values, information strings, total number of transactions, etc.), even when the adversary can
adaptively induce honest parties to perform DAP operations of his choice. That is, no bounded
adversary A can distinguish between two ledgers L0 and L1, constructed by A using queries to two
DAP scheme oracles, when the queries to the two oracles are publicly consistent: they have matching
type and are identical in terms of publicly-revealed information and the information related to
addresses controlled by A.
Ledger indistinguishability is formalized by an experiment L-IND that proceeds as follows.
First, a challenger samples a random bit b and initializes two DAP scheme oracles ODAP
and
, maintaining ledgers L0 and L1. Throughout, the challenger allows A to issue queries to
ODAP
and ODAP
ODAP
, thus controlling the behavior of honest parties on L0 and L1. The challenger
provides the adversary with the view of both ledgers, but in randomized order: LLeft := Lb and
LRight := L1−b. The adversary’s goal is to distinguish whether the view he sees corresponds to
(LLeft, LRight) = (L0, L1), i.e. b = 0, or to (LLeft, LRight) = (L1, L0), i.e. b = 1.
At each round of the experiment, the adversary issues queries in pairs Q, Q(cid:48) of matching query
type. If the query type is CreateAddress, then the same address is generated at both oracles. If
it is to Mint, Pour or Receive, then Q is forwarded to L0 and Q(cid:48) to L1; for Insert queries, query
Q is forwarded to LLeft and Q(cid:48) is forwarded to LRight. The adversary’s queries are restricted in the
sense that they must maintain the public consistency of the two ledgers. For example, the public
values for Pour queries must be the same, as well as minted amounts for Mint queries.
At the conclusion of the experiment, A outputs a guess b(cid:48), and wins when b = b(cid:48). Ledger
indistinguishability requires that A wins L-IND with probability at most negligibly greater than 1/2.
Transaction non-malleability. This property requires that no bounded adversary A can alter
any of the data stored within a (valid) pour transaction txPour. This transaction non-malleability
prevents malicious attackers from modifying others’ transactions before they are added to the ledger
(e.g., by re-targeting the Basecoin public output of a pour transaction).
Transaction non-malleability is formalized by an experiment TR-NM, in which A adaptively
interacts with a DAP scheme oracle ODAP and then outputs a pour transaction tx∗. Letting T
denote the set of pour transactions returned by ODAP, and L denote the ﬁnal ledger, A wins the
game if there exists tx ∈ T , such that (i) tx∗ (cid:54)= tx; (ii) tx∗ reveals a serial number contained in tx;
and (iii) both tx and tx∗ are valid with respect to the ledger L(cid:48) containing all transactions preceding
tx on L. In other words, A wins the game if tx∗ manages to modify some previous pour transaction
to spend the same coin in a diﬀerent way.
Transaction non-malleability requires that A wins TR-NM with only negligible probability. (Note
that A can of course produce valid pour transactions that are unrelated to those in T ; the condition
that tx∗ reveals a serial number of a previously-spent coin captures non-malleability.)
Balance. This property requires that no bounded adversary A can own more money than what
he minted or received via payments from others.
Balance is formalized by an experiment BAL, in which A adaptively interacts with a DAP scheme
oracle ODAP and then outputs a set of coins Scoin. Letting ADDR be set of addresses returned by
CreateAddress queries (i.e., addresses of “honest” users), A wins the game if the total value he
can spend or has spent (either as coins or Basecoin public outputs) is greater than the value he
has minted or received. That is, A wins if vUnspent + vBasecoin + vA→ADDR > vMint + vADDR→A where:
(i) vUnspent is the total value of unspent coins in Scoin; (ii) vBasecoin is the total value of public outputs
placed by A on the ledger; (iii) vMint is the total value of A’s mint transactions; (iv) vADDR→A is
the total value of payments received by A from addresses in ADDR; (v) vA→ADDR is the total value

17

of payments sent by A to addresses in ADDR.

Balance requires that A wins BAL with only negligible probability.

4 Construction of a decentralized anonymous payment scheme

We show how to construct a DAP scheme (introduced in Section 3) using zk-SNARKs and other
building blocks. Later, in Section 5, we give a concrete instantiation of this construction.

4.1 Cryptographic building blocks

x

x (z) := PRFx(01(cid:107)z) , PRFpk

(z) := PRFx(00(cid:107)z) , PRFsn
x(cid:48) (z(cid:48)).

We ﬁrst introduce notation for the standard cryptographic building blocks that we use. We
assume familiarity with the deﬁnitions of these building blocks; for more details, see, e.g., [KL07].
Throughout, λ denotes the security parameter.
Collision-resistant hashing. We use a collision-resistant hash function CRH : {0, 1}∗ → {0, 1}O(λ).
Pseudorandom functions. We use a pseudorandom function family PRF = {PRFx : {0, 1}∗ →
{0, 1}O(λ)}x where x denotes the seed. From PRFx, we derive three “non-overlapping” pseudorandom
functions, chosen arbitrarily as PRFaddr
x (z) :=
PRFx(10(cid:107)z). Furthermore, we assume that PRFsn is also collision resistant, in the sense that it is
infeasible to ﬁnd (x, z) (cid:54)= (x(cid:48), z(cid:48)) such that PRFsn
Statistically-hiding commitments. We use a commitment scheme COMM where the bind-
ing property holds computationally, while the hiding property holds statistically. It is denoted
{COMMx : {0, 1}∗ → {0, 1}O(λ)}x where x denotes the commitment trapdoor. Namely, to reveal a
commitment cm to a value z, it suﬃces to provide z and the trapdoor x; then one can check that
cm = COMMx(z).
One-time strongly-unforgeable digital signatures. We use a digital signature scheme Sig =
(Gsig,Ksig,Ssig,Vsig) that works as follows.
• Gsig(1λ) → ppsig. Given a security parameter λ (presented in unary), Gsig samples public parameters
• Ksig(ppsig) → (pksig, sksig). Given public parameters ppsig, Ksig samples a public key and a secret
• Ssig(sksig, m) → σ. Given a secret key sksig and a message m, Ssig signs m to obtain a signature σ.
• Vsig(pksig, m, σ) → b. Given a public key pksig, message m, and signature σ, Vsig outputs b = 1 if

ppsig for the encryption scheme.

key for a single user.

x (z) = PRFsn

the signature σ is valid for message m; else it outputs b = 0.

The signature scheme Sig satisﬁes the security property of one-time strong unforgeability against
chosen-message attacks (SUF-1CMA security).
Key-private public-key encryption. We use a public-key encryption scheme Enc = (Genc,Kenc,
Eenc,Denc) that works as follows.
• Genc(1λ) → ppenc. Given a security parameter λ (presented in unary), Genc samples public
• Kenc(ppenc) → (pkenc, skenc). Given public parameters ppenc, Kenc samples a public key and a
• Eenc(pkenc, m) → c. Given a public key pkenc and a message m, Eenc encrypts m to obtain a
• Denc(skenc, c) → m. Given a secret key skenc and a ciphertext c, Denc decrypts c to produce a

parameters ppenc for the encryption scheme.

secret key for a single user.

ciphertext c.
message m (or ⊥ if decryption fails).

The encryption scheme Enc satisﬁes two security properties: (i) ciphertext indistinguishability under
chosen-ciphertext attack (IND-CCA security); and (ii) key indistinguishability under chosen-ciphertext

18

attack (IK-CCA security). While the ﬁrst property is standard, the second is less known; informally,
IK-CCA requires that ciphertexts cannot be linked to the public key used to encrypt them, or to other
ciphertexts encrypted with the same public key. For deﬁnitions, we refer the reader to [BBDP01].

4.2 zk-SNARKs for pouring coins

As outlined in Section 1.3, our construction invokes a zk-SNARK for a speciﬁc NP statement, POUR,
which we now deﬁne. We ﬁrst recall the context motivating POUR. When a user u pours “old” coins
cold
1 , cold
2

, a corresponding pour transaction

into new coins cnew

, cnew

1

2

txPour = (rt, snold

1 , snold

2 , cmnew

1

, cmnew

2

, vpub, info,∗)

2

1

, cnew

1 , snold
2

are of cold

2 ; (ii) coin commitments for cold
1 , cold

is generated. In our construction, we need to provide evidence in “∗” that various conditions
were respected by the pour operation. Concretely, txPour should demonstrate that (i) u owns
cold
1 , cold
appear somewhere on the ledger; (iii) the revealed
serial numbers snold
are
of cnew
; (v) balance is preserved. Our construction achieves this by including a zk-SNARK
proof πPOUR for the statement POUR which checks the above invariants (as well as others needed for
non-malleability).
The statement POUR. Concretely, the NP statement POUR is deﬁned as follows.
• Instances are of the form x = (rt, snold

1 , cold
2
2 ; (iv) the revealed coin commitments cmnew

, vpub, hSig, h1, h2). Thus, an instance x
speciﬁes a root rt for a CRH-based Merkle tree (over the list of commitments so far), the two
serial numbers of the consumed coins, two coin commitments for the two new coins, a public
value, and ﬁelds hSig, h1, h2 used for non-malleability.

2 , cmnew

1 , snold

, cmnew

, cmnew

1

2

1

2

• Witnesses are of the form a = (path1, path2, cold

1 , cold

2 , addrold

sk,1, addrold

sk,2, cnew

1

, cnew

2

) where, for each

i ∈ {1, 2}:

i

, ρold
, ρnew

i

, rold

, sold

, cmold

i
, rnew

i
, snew

i

i

i ) ,
, cmnew

i

) for the same cmnew

as in x,

i

i

cold
i = (addrold
cnew
i = (addrnew
pk,i = (aold
addrold
pk,i = (anew
addrnew
sk,i = (aold
addrold

pk,i, vold
pk,i, vnew
enc,i) ,
enc,i) ,
enc,i) .

i
pk,i, pkold
pk,i, pknew
sk,i, skold

Thus, a witness a speciﬁes authentication paths for the two new coin commitments, the entirety
of coin information about both the old and new coins, and address secret keys for the old coins.

Given a POUR instance x, a witness a is valid for x if the following holds:
1. For each i ∈ {1, 2}:

(a) The coin commitment cmold

of cold

i

i

appears on the ledger, i.e., pathi is a valid authentication

path for leaf cmold

i with respect to root rt, in a CRH-based Merkle tree.

(b) The address secret key aold
(c) The serial number snold
(d) The coin cold
(e) The coin cnew
(f) The address secret key aold

i

i

i

sk,i matches the address public key of cold
of cold

is computed correctly, i.e., snold

i

i

is well-formed, i.e., cmold
is well-formed, i.e., cmnew

i = COMMsold
i = COMMsnew

i

i

(COMMrold

(COMMrnew

sk,i ties hSig to hi, i.e., hi = PRFpk
aold
sk,i

(0).

, i.e., aold

pk,i = PRFaddr
aold
sk,i
(ρold
i ).
i )(cid:107)vold
).

i

)(cid:107)vnew

i

).

i = PRFsn
aold
pk,i(cid:107)ρold
sk,i
(aold
pk,i(cid:107)ρnew
(anew
(i(cid:107)hSig).

i

i

i

19

1 + vnew

2 + vpub = vold

2. Balance is preserved: vnew

2 ≤ vmax).
Recall that in this paper zk-SNARKs are relative to the language of arithmetic circuit satisﬁability
(see Section 2); thus, we express the checks in POUR via an arithmetic circuit, denoted CPOUR. In
particular, the depth dtree of the Merkle tree needs to be hardcoded in CPOUR, and we thus make it a
parameter of our construction (see below); the maximum number of supported coins is then 2dtree.

2 ≥ 0 and vold

1 + vold

1 + vold
2

(with vold

1 , vold

4.3 Algorithm constructions

We proceed to describe the construction of the DAP scheme Π = (Setup, CreateAddress, Mint, Pour,
VerifyTransaction, Receive) whose intuition was given in Section 1.3. Figure 2 gives the pseudocode
for each one of the six algorithms in Π, in terms of the building blocks introduced in Section 4.1
and Section 4.2. In the construction, we hardcode two quantities: the maximum value of a coin,
vmax, and the depth of the Merkle tree, dtree.

4.4 Completeness and security

Our main theorem states that the above construction is indeed a DAP scheme.

Theorem 4.1. The tuple Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive), as de-
ﬁned in Section 4.3, is a complete (cf. Deﬁnition 3.1) and secure (cf. Deﬁnition 3.2) DAP scheme.

We provide a proof of Theorem 4.1 in Appendix D. We note that our construction can be modiﬁed
to yield statistical (i.e., everlasting) anonymity; see the discussion in Section 8.1.

Remark (trusted setup). Security of Π relies on a trusted party running Setup to generate the
public parameters (once and for all). This trust is needed for the transaction non-malleability
and balance properties but not for ledger indistinguishability. Thus, even if a powerful espionage
agency were to corrupt the setup, anonymity will still be maintained. Moreover, if one wishes to
mitigate the trust requirements of this step, one can conduct the computation of Setup using secure
multiparty computation techniques; we leave this to future work.

Remark (use of pp). According to the deﬁnition of a DAP scheme (see Section 3), the public
parameters pp are given as input to each one of the six algorithms; this is also how we presented
our construction in Figure 2. However, in our construction, the public parameters pp equal a
tuple (pkPOUR, vkPOUR, ppenc, ppsig), and not every algorithm needs every component of pp. Concretely,
CreateAddress only needs ppenc; Mint only the security parameter λ; Pour only pkPOUR and ppsig;
VerifyTransaction only vkPOUR; and Receive only λ. In particular, since we rely on zk-SNARKs to
prove/verify POUR, pkPOUR is of constant, but large, size, and is only required by Pour. All other
components of pp are of small constant size.

Remark (checking received coins in ledger). The algorithm Receive tests whether the serial number
of a received coin already appears on the ledger, in order not to output coins that the user has
already received and spent by himself. Other users are, in any case, unable to spend coins addressed
to this user.

5 Zerocash

We describe a concrete instantiation of a DAP scheme; this instantiation forms the basis of Zerocash.
Later, in Section 6, we discuss how Zerocash can be integrated with existing ledger-based currencies.

20

Setup
• inputs: security parameter λ
• outputs: public parameters pp
1. Construct CPOUR for POUR at security λ.
2. Compute (pkPOUR, vkPOUR) := KeyGen(1λ, CPOUR).
3. Compute ppenc := Genc(1λ).
4. Compute ppsig := Gsig(1λ).
5. Set pp := (pkPOUR, vkPOUR, ppenc, ppsig).
6. Output pp.

CreateAddress
• inputs: public parameters pp
• outputs: address key pair (addrpk, addrsk)
1. Compute (pkenc, skenc) := Kenc(ppenc).
2. Randomly sample a PRFaddr seed ask.
3. Compute apk = PRFaddr
4. Set addrpk := (apk, pkenc).
5. Set addrsk := (ask, skenc).
6. Output (addrpk, addrsk).

ask (0).

Mint
• inputs:

– public parameters pp
– coin value v ∈ {0, 1, . . . , vmax}
– destination address public key addrpk

• outputs: coin c and mint transaction txMint
1. Parse addrpk as (apk, pkenc).
2. Randomly sample a PRFsn seed ρ.
3. Randomly sample two COMM trapdoors r, s.
4. Compute k := COMMr(apk(cid:107)ρ).
5. Compute cm := COMMs(v(cid:107)k).
6. Set c := (addrpk, v, ρ, r, s, cm).
7. Set txMint := (cm, v,∗), where ∗ := (k, s).
8. Output c and txMint.

VerifyTransaction
• inputs:

– public parameters pp
– a (mint or pour) transaction tx
– the current ledger L

• outputs: bit b, equals 1 iﬀ the transaction is valid
1. If given a mint transaction tx = txMint:

(a) Parse txMint as (cm, v,∗), and ∗ as (k, s).
(b) Set cm(cid:48) := COMMs(v(cid:107)k).
(c) Output b := 1 if cm = cm(cid:48), else output b := 0.

(a) Parse txPour as (rt, snold

2. If given a pour transaction tx = txPour:
2 , cmnew
∗ as (pksig, h1, h2, πPOUR, C1, C2, σ).
2 appears on L (or snold

1 or snold

1 , snold

1

, cmnew

2

, vpub, info,∗), and

2 ), output b := 0.

1 = snold

(b) If snold
(c) If the Merkle root rt does not appear on L, output b := 0.
(d) Compute hSig := CRH(pksig).
(e) Set x := (rt, snold
2 , cmnew
(f) Set m := (x, πPOUR, info, C1, C2).
(g) Compute b := Vsig(pksig, m, σ).
(h) Compute b(cid:48) := Verify(vkPOUR, x, πPOUR), and output b ∧ b(cid:48).

, vpub, hSig, h1, h2).

1 , snold

, cmnew

1

2

Pour
• inputs:

– public parameters pp
– the Merkle root rt
– old coins cold
1 , cold
2
– old addresses secret keys addrold
– path path1 from commitment cm(cold
path path2 from commitment cm(cold

sk,1, addrold
sk,2

1 ) to root rt,
2 ) to root rt

2

1

, vnew

– new values vnew
– new addresses public keys addrnew
– public value vpub
– transaction string info
• outputs: new coins cnew
1. For each i ∈ {1, 2}:

, cnew

1

2

pk,1, addrnew
pk,2

and pour transaction txPour

i

i

i

i ).

, sold

, rold

, cmold

pk,i as (anew

:= PRFsn
aold
sk,i

, ρold
enc,i).
(ρold

pk,i, vold
i
sk,i, skold

i as (addrold
sk,i as (aold

(a) Parse cold
(b) Parse addrold
(c) Compute snold
i
(d) Parse addrnew
(e) Randomly sample a PRFsn seed ρnew
.
(f) Randomly sample two COMM trapdoors rnew
pk,i(cid:107)ρnew
(g) Compute knew
).
i (cid:107)knew
(vnew
(h) Compute cmnew
, snew
(i) Set cnew
, rnew
:= (addrnew
(j) Set Ci := Eenc(pknew

i ).
enc,i).

:= COMMrnew

pk,i, pknew

i
, rnew

).
, cmnew

i
, snew

(anew

i
)).

i

i

i

i

i

i

i

i

, snew

i

.

).

i

i

i

i

i

:= COMMsnew
, ρnew
pk,i, vnew
i
, ρnew
enc,i, (vnew
i
2. Generate (pksig, sksig) := Ksig(ppsig).
3. Compute hSig := CRH(pksig).
4. Compute h1 := PRFpk
aold
, cmnew
5. Set x := (rt, snold
2 , cmnew
1 , snold
6. Set a := (path1, path2, cold
2 , addrold
7. Compute πPOUR := Prove(pkPOUR, x, a).
8. Set m := (x, πPOUR, info, C1, C2).
9. Compute σ := Ssig(sksig, m).
10. Set txPour := (rt, snold

2 , cmnew
∗ := (pksig, h1, h2, πPOUR, C1, C2, σ).

1 , snold

1 , cold

sk,1

1

2

1

2

11. Output cnew

1

, cnew

2

and txPour.

(1(cid:107)hSig) and h2 := PRFpk

(2(cid:107)hSig).

aold

sk,2

, vpub, hSig, h1, h2).
sk,2, cnew
sk,1, addrold

1

, cnew

2

).

, cmnew

, vpub, info,∗), where

Receive
• inputs:

– public parameters pp
– recipient address key pair (addrpk, addrsk)
– the current ledger L

• outputs: set of received coins
1. Parse addrpk as (apk, pkenc).
2. Parse addrsk as (ask, skenc).
3. For each Pour transaction txPour on the ledger:
, cmnew

(a) Parse txPour as (rt, snold
(b) For each i ∈ {1, 2}:

and ∗ as (pksig, h1, h2, πPOUR, C1, C2, σ).

2 , cmnew

1 , snold

1

2

, vpub, info,∗),

i. Compute (vi, ρi, ri, si) := Denc(skenc, Ci).
ii. If Denc’s output is not ⊥, verify that:

• cmnew
• sni := PRFsn

i

equals COMMsi (vi(cid:107)COMMri (apk(cid:107)ρi));

ask (ρi) does not appear on L.

iii. If both checks succeed, output
ci := (addrpk, vi, ρi, ri, si, cmnew

i

).

Figure 2: Construction of a DAP scheme using zk-SNARKs and other ingredients.

21

5.1 Instantiation of building blocks

We instantiate the DAP scheme construction from Section 4 (see Figure 2), aiming at a level of
security of 128 bits. Doing so requires concrete choices, described next.
CRH, PRF, COMM from SHA256. Let H be the SHA256 compression function, which maps
a 512-bit input to a 256-bit output. We mostly rely on H, rather than the “full” hash, since
this suﬃces for our ﬁxed-size single-block inputs, and it simpliﬁes the construction of CPOUR (see
Section 5.2). We instantiate CRH, PRF, COMM via H (under suitable assumptions on H).
First, we instantiate the collision-resistant function CRH as H(z) for z ∈ {0, 1}512; this function
Next, we instantiate the pseudorandom function PRFx(z) as H(x(cid:107)z), with x ∈ {0, 1}256 as the

compresses “two-to-one”, so it can be used to construct binary Merkle trees.14
seed, and z ∈ {0, 1}256 as the input.15 Thus, the derived functions are:
x (z) := H(x(cid:107)01(cid:107)z) , PRFpk

(z) := H(x(cid:107)00(cid:107)z) , PRFsn

x (z) := H(x(cid:107)10(cid:107)z) ,

PRFaddr

x

with x ∈ {0, 1}256 and z ∈ {0, 1}254.

As for the commitment scheme COMM, we only use it in the following pattern:

k := COMMr(apk(cid:107)ρ) ,
cm := COMMs(v(cid:107)k) .

Due to our instantiation of PRF, apk is 256 bits. So we can set ρ also to 256 bits and r to
256 + 128 = 384 bits; then we can compute

k := COMMr(apk(cid:107)ρ) as H(r(cid:107)[H(apk(cid:107)ρ)]128) .

Above, [·]128 denotes that we are truncating the 256-bit string to 128 bits (say, by dropping least-
signiﬁcant bits, as in our implementation). Heuristically, for any string z ∈ {0, 1}128, the distribution
induced by H(r(cid:107)z) is 2−128-close to uniform, and this forms the basis of the statistically-hiding
property. For computing cm, we set coin values to be 64-bit integers (so that, in particular,
vmax = 264 − 1 in our implementation), and then compute

cm := COMMs(v(cid:107)k) as H(k(cid:107)0192(cid:107)v) .

Noticeably, above we are ignoring the commitment randomness s. The reason is that we already
know that k, being the output of a statistically-hiding commitment, can serve as randomness for
the next commitment scheme.
Instantiating the NP statement POUR. The above choices imply a concrete instantiation of
the NP statement POUR (see Section 4.2). Speciﬁcally, in our implementation, POUR checks that the
following holds, for each i ∈ {1, 2}:
• pathi is an authentication path for leaf cmold
• aold
• snold
• cmold

i with respect to root rt, in a CRH-based Merkle tree;

pk,i = H(aold
i = H(aold
i = H(H(rold

sk,i(cid:107)0256);
sk,i(cid:107)01(cid:107)[ρold

i )]128)(cid:107)0192(cid:107)vold

i (cid:107)[H(aold

]254);
pk,i(cid:107)ρold

);

i

i

14A single exception: we still compute hSig according to the full hash SHA256, rather than its compression function,

because there is no need for this computation to be veriﬁed by CPOUR.

15This assumption is reminiscent of previous works analyzing the security of hash-based constructions (e.g., [Bel06]).
However in this work we assume that a portion of the compression function is the seed for the pseudorandom function,
rather than using the chaining variable as in [Bel06].

22

i = H(H(rnew

• cmnew
• hi = H(aold
Moreover, POUR checks that vnew

); and
sk,i(cid:107)10(cid:107)bi(cid:107)[hSig]253) where b1 := 0 and b2 := 1.
1 + vold

)]128)(cid:107)0192(cid:107)vnew

2 + vpub = vold

pk,i(cid:107)ρnew

(cid:107)[H(anew

i

i

i

2 ≥ 0 and vold

2 < 264.
Finally, as mentioned, in order for CPOUR to be well-deﬁned, we need to ﬁx a Merkle-tree depth

2 , with vold

1 + vnew

1 + vold

1 , vold

dtree. In our implementation, we ﬁx dtree = 64, and thus support up to 264 coins.
Instantiating Sig. For the signature scheme Sig, we use ECDSA to retain consistency and
compatibility with the existing bitcoind source code. However, standard ECDSA is malleable:
both (r, s) and (r,−s) verify as valid signatures. We use a non-malleable variant, where s is restricted
to the “lower half” of ﬁeld elements. While we are not aware of a formal SUF-1CMA proof for this
variant, its use is consistent with proposals to resolve Bitcoin transaction malleability [Wui14].16
Instantiating Enc. For the encryption scheme Enc, we use the key-private Elliptic-Curve Integrated
Encryption Scheme (ECIES) [Cer00]; it is one of the few standardized key-private encryption schemes
with available implementations.

5.2 Arithmetic circuit for pouring coins

Our DAP scheme construction from Section 4 (see Figure 2) also requires zk-SNARKs relative
to the NP statement POUR. These are obtained by invoking a zk-SNARK for arithmetic circuit
satisﬁability (see Section 2.4) on an arithmetic circuit CPOUR, which veriﬁes the NP statement POUR.
In our instantiation, we rely on the implementation of [BCTV14] for the basic zk-SNARK (see
Section 2.4), and apply it to the circuit CPOUR whose construction is described next.

5.2.1 An arithmetic circuit for verifying SHA256’s compression function
The vast majority of the “veriﬁcation work” in POUR is verifying computations of H, the compression
function of SHA256 (see Section 5.1). Thus, we begin by discussing our construction of an arithmetic
circuit CH for verifying SHA256 computations. Later, in Section 5.2.2, we discuss the construction
of CPOUR, given the circuit CH.
We wish to construct an arithmetic circuit CH such that, for every 256-bit digest h and 512-bit
input z, (h, z) ∈ RCH if and only if h = H(z). Naturally, our goal is to minimize the size of
CH. Our high-level strategy is to construct CH, piece by piece, by closely following the SHA256
oﬃcial speciﬁcation [Nat12]. For each subcomputation of SHA256, we use nondeterminism and ﬁeld
operations to verify the subcomputation using as few gates as possible.

Overview of SHA256’s compression function. The primitive unit in SHA256 is a 32-bit word.
All subcomputations are simple word operations: three bitwise operations (and, or, xor), shift-right,
rotate-right, and addition modulo 232. The compression function internally has a state of 8 words,
initialized to a ﬁxed value, and then transformed in 64 successive rounds by following the 64-word
message schedule (deduced from the input z). The 256-bit output is the concatenation of the 8
words of the ﬁnal state.
Representing a state. We ﬁnd that, for each word operation (except for addition modulo 232),
it is more eﬃcient to verify the operation when its inputs are represented as separate wires, each
carrying a bit. Thus, CH maintains the 8-word state as 256 individual wires, and the 64-word
message schedule as 64 · 32 wires.
Addition modulo 32. To verify addition modulo 232 we use techniques employed in previous
i=0 2i(Ai + Bi).
16In practice, one might replace this ECDSA variant with an EC-Schnorr signature satisfying SUF-1CMA security

work [PGHR13, BCG+13, BCTV14]. Given two words A and B, we compute α :=(cid:80)31

with proper encoding of EC group elements; the performance would be similar.

23

carry), and enforce consistency by requiring that α =(cid:80)32

Because F has characteristic larger than 233, there is no wrap around; thus, ﬁeld addition coincides
with integer addition. We then make a non-deterministic guess for the 33 bits αi of α (including
i=0 2iαi. To ensure that each αi ∈ {0, 1},
we use a 33-gate subcircuit computing αi(αi − 1), all of which must be 0 for the subcircuit to be
satisﬁable. Overall, verifying addition modulo 232 only requires 34 gates. This approach extends in
a straightforward way to summation of more than two terms.
Verifying the SHA256 message schedule. The ﬁrst 16 words Wi of the message schedule are
the 16 words of the 512-bit input z. The remaining 48 words are computed as Wt := σ1(Wt−2) +
Wt−7 + σ0(Wt−15) + Wt−16, where σ0(W ) := rotr7(W )⊕ rotr18(W )⊕ shr3(W ) and σ1 has the same
structure but diﬀerent rotation and shift constants.

The rotation and shift amounts are constants, so rotates and shifts can be achieved by suitable
wiring to previously computed bits (or the constant 0 for high-order bits in shr). Thus, since the
XOR of 3 bits can be computed using 2 gates, both σ0 and σ1 can be computed in 64 gates. We
then compute (or more precisely, guess and verify) the addition modulo 232 of the four terms.
Verifying the SHA256 round function. The round function modiﬁes the 8-word state by
changing two of its words and then permuting the 8-word result.

Each of the two modiﬁed words is a sum modulo 232 of (i) round-speciﬁc constant words Kt;
(ii) message schedule words Wt; and (iii) words obtained by applying simple functions to state
words. Two of those functions are bitwise majority (Maj(A, B, C)i = 0 if Ai + Bi + Ci ≤ 1 else 1)
and bitwise choice (Ch(A, B, C)i = Bi if Ai = 1, else Ci). We verify correct computation of Maj
using 2 gates per output bit, and Ch with 1.

Then, instead of copying 6 unchanged state words to obtain the permuted result, we make the
permutation implicit in the circuit’s wiring, by using output wires of previous sub-computations
(sometimes reaching 4 round functions back) as input wires to the current sub-computation.
Performance. Overall, we obtain an arithmetic circuit CH for verifying SHA256’s compression
function with less than 30 000 arithmetic gates. See Figure 3 for a breakdown of gate counts.

Gate count for CH

Message schedule
All rounds

1 round (of 64)

Finalize
Total

8032
19 584
306
288
27 904

Figure 3: Size of circuit CH for SHA256’s compression function.

Comparison with generic approaches. We constructed the circuit CH from scratch. We could
have instead opted for more generic approaches:
implement SHA256’s compression function in
a higher-level language, and use a circuit generator to obtain a corresponding circuit. However,
generic approaches are signiﬁcantly more expensive for our application, as we now explain.
Starting from the SHA256 implementation in PolarSSL (a popular cryptographic library) [Pol13],
it is fairly straightforward to write a C program for computing H. We wrote such a program, and
gave it as input to the circuit generator of [PGHR13]. The output circuit had 58160 gates, more
than twice larger than our hand-optimized circuit.

Alternatively, we also compiled the same C program to TinyRAM, which is the architecture
supported in [BCG+13]; we obtained a 5371-instruction assembly code that takes 5704 cycles to
execute on TinyRAM. We could then invoke the circuit generator in [BCG+13] when given this
TinyRAM program and time bound. However, each TinyRAM cycle costs ≈ 1000 gates, so the
resulting circuit would have at least 5.7 · 106 gates, i.e., over 190 times larger than our circuit. A

24

similar computation holds for the circuit generator in [BCTV14], which supports an even more
ﬂexible architecture.

Thus, overall, we are indeed much better oﬀ constructing CH from scratch. Of course, this is
not surprising, because a SHA256 computation is almost a “circuit computation”: it does not make
use of complex program ﬂow, accesses to memory, and so on. Thus, relying on machinery developed
to support much richer classes of programs does not pay oﬀ.

5.2.2 Arithmetic circuit for POUR
The NP statement POUR requires verifying membership in a Merkle tree based on H, a few additional
invocations of H, and integer addition and comparison. We construct the circuit CPOUR for POUR by
combining various subcircuits verifying each of these. There remains to to discuss the subcircuits
for verifying membership in a Merkle tree (using the aforementioned subcircuit CH for verifying
invocations of H), and integer addition and comparison.
Merkle tree membership. We need to construct an arithmetic circuit that, given a root rt,
authentication path path, and coin commitment cm, is satisﬁed if and only if path is a valid
authentication path for the leaf cm with respect to the root rt. The authentication path path
includes, for each layer i, an auxiliary hash value hi and a bit ri specifying whether hi was the left
(ri = 0) or the right (ri = 1) child of the parent node. We then check membership in the Merkle
tree by verifying invocations of H, bottom-up. Namely, for d = 64, we set kd−1 = cm; then, for each
i = d − 1, . . . , 1, we set Bi = hi(cid:107)ki if ri = 0 else ki(cid:107)hi, and compute ki−1 = H(Bi). Finally we check
that the root k0 matches the given root rt.
Integer addition. We need to construct an arithmetic circuit that, given 64-bit integers A, B, C
(presented as binary strings), is satisﬁed if and only if C = A + B over the integers. Again relying
i=0 2ici =

on the fact that F’s characteristic is suﬃciently large, we do so by checking that (cid:80)63
(cid:80)63
do so by checking that(cid:80)63
of ci can satisfy the constraint as(cid:80)63

Integer comparison. We need to construct an arithmetic circuit that, given two 64-bit integers
A, B (represented in binary), is satisﬁed if and only if A + B ﬁts in 64 bits (i.e. A + B < 264). We
i=0 ci for some ci ∈ {0, 1}. Indeed, if A + B < 264 then
it suﬃces to take ci as the binary representation of A + B. However, if A + B ≥ 264 then no choice
i=0 ci ≤ 264 − 1. Overall, this requires 65 gates (1 gate for the

i=0 2i(bi + ai) over F; this is enough, because there is no wrap around.

i=0 2i(bi + ai) =(cid:80)63

equality check, and 64 gates for ensuring that c0, . . . , c63 are boolean).
Overall circuit sizes. See Figure 4 for the size of CPOUR. More than 99% of the gates are devoted
to verifying invocations of H.

Gate count for CPOUR

Ensure cmold
1

is in Merkle tree

(1 layer out of 64)

Ensure cmold
2

is in Merkle tree

(1 layer out of 64)

Check computation of snold
Check computation of aold
Check computation of cmold
Check computation of h1, h2
Ensure that vnew
Ensure that vold
Miscellaneous
Total

1 + vnew
1 + vold

1 , snold
2
pk,1, aold
pk,2
1 , cmold

2 , cmnew

1

, cmnew

2

2 + vpub = vold
2 < 264

1 + vold
2

1 802 304
(28 161)
1 802 304
(28 161)
2 × 27 904
2 × 27 904
4 × 83 712
2 × 27 904
1
65
2384
4 109 330

Figure 4: Size of the circuit CPOUR, which veriﬁes the statement POUR.

25

6

Integration with existing ledger-based currencies

Zerocash can be deployed atop any ledger (even one maintained by a central bank). Here, we brieﬂy
detail integration with the Bitcoin protocol. Unless explicitly stated otherwise, in the following
section when referring to Bitcoin, and its unit of account bitcoin (plural bitcoins), we mean the
underlying protocol and software, not the currency system. (The discussion holds, with little or no
modiﬁcation, for many forks of Bitcoin, also known as “altcoins”, such as Litecoin.)

By introducing new transaction types and payment semantics, Zerocash breaks compatibility
with the Bitcoin network. While Zerocash could be integrated into Bitcoin (the actual currency and
its supporting software) via a “ﬂag day” where a super-majority of Bitcoin miners simultaneously
adopt the new software, we neither expect nor advise such integration in the near future and suggest
using Zerocash in a separate altcoin.

Integrating Zerocash into Bitcoin consists of adding a new transaction type, Zerocash transactions,
and modifying the protocol and software to invoke Zerocash’s DAP interface to create and verify
these transactions. There are at least two possible approaches to this integration. The ﬁrst approach
replaces all bitcoins with zerocoins, making all transactions anonymous at the cost of losing any
additional Bitcoin functionality provided by, e.g., the Bitcoin scripting language (see Section 6.1).
The second approach maintains this functionality, adding a parallel Zerocash currency, zerocoin,
which can be converted to and from bitcoin at a one-to-one rate (see Section 6.2). Options for
protocol-level modiﬁcations for the later approach are discussed in Section 6.3; the former can be
readily inferred. In Section 6.4 we discuss anonymizing the network layer of Bitcoin and anonymity
safeguards.

6.1 Integration by replacing the base currency

One approach is to alter the underlying system so that all monetary transactions are done using
Zerocash, i.e., by invoking the DAP interface and writing/reading the associated transactions in the
distributed ledger.

As seen in Section 3, this suﬃces to oﬀer the core functionality of payments, minting, merging,
splitting, etc., while assuring users that all transactions using this currency are anonymous. However,
this has several drawbacks: (1) All pour transactions incur the cost of generating a zk-SNARK proof.
(2) If Bitcoin supports additional features, such as a scripting language for specifying conditions for
claiming bitcoins (as in Bitcoin), then these features are lost.17 (3) Bitcoin allows the ﬂexibility of
spending unconﬁrmed transactions; instead, with a Zerocash-only Bitcoin, this ﬂexibility is lost:
transactions must be conﬁrmed before they can be spent. (And this imposes a minimal delay
between receiving funds and spending them.)

6.2 Integration by hybrid currency

A diﬀerent approach is to extend Bitcoin with a parallel, anonymized currency of “zerocoins”,
existing alongside bitcoins, using the same ledger, and with the ability to convert freely between
the two. The behavior and functionality of regular bitcoins is unaltered; in particular, they may
support functionality such as scripting.

In this approach, the Bitcoin ledger consists of Bitcoin-style transactions, containing inputs and
outputs [Nak09]. Each input is either a pointer to an output of a previous transaction (as in plain
Bitcoin), or a Zerocash pour transaction (which contributes its public value, vpub, of bitcoins to
this transaction). Outputs are either an amount and destination public address/script (as in plain

17However, in principle POUR could be extended to include a scripting language interpreter.

26

Bitcoin), or a Zerocash mint transaction (which consumes the input bitcoins to produce zerocoins).
The usual invariant over bitcoins is maintained and checked in plain view: the sum of bitcoin inputs
(including pours’ vpub) must be at least the sum of bitcoin outputs (including mints’ v), and any
diﬀerence is oﬀered as a transaction fee. However, the accounting for zerocoins consumed and
produced is done separately and implicitly by the DAP scheme.

The life cycle of a zerocoin is as follows.

Creating new zerocoins. A mint transaction consumes v worth of bitcoins as inputs, and outputs
coin commitment worth v zerocoins. The v bitcoins are eﬀectively destroyed, in exchange for the
newly-minted zerocoins.
Spending zerocoins. Zerocoins can then be transferred, split, and merged into other zerocoins
arbitrarily, via pour transactions which, instead of explicit inputs, include zero-knowledge proofs
that such inputs exist. Pour transactions may optionally reveal a non-zero public output vpub. This
is either left unclaimed as a transaction fee,18 placed into a standard Bitcoin transaction output
(e.g., one paying to a public key) or consumed by a mint transaction. Thus, vpub bitcoins are created
ex nihilo (similarly to how coinbase transactions produce bitcoin outputs as mining reward), in
exchange for destroying that amount of zerocoins. The Bitcoin outputs must be included in the
transaction string info, which is included as part of a pour transaction; transaction non-malleability
ensures that all this information is bound together.
Spending multiple zerocoins. To allow for pours to span more than two input and output coins,
txPour structures may be chained together within one transaction by marking some output coin
commitments as intermediates and having subsequent pours in the same transaction constructed
relative to an ephemeral Merkle tree consisting of only the intermediates commitments. For example,
a transaction might accept four input coins, with the ﬁrst two Pour operations combining two
of the inputs to produce an intermediate commitment each and a ﬁnal Pour combining the two
intermediate commitments into a ﬁnal output new coin. Since the intermediate results are consumed
instantly within the transaction, they need not be recorded in the global Merkle tree or have their
serial numbers marked as spent.
Transaction fees. Collecting transaction fees is done as usual, via a coinbase transaction added
to each block, which pays as mining reward the diﬀerence between the total inputs (bitcoin and
pours’ vpub) and total outputs (bitcoin and mints’ v) in this block. Payment is either in bitcoins or
in newly-minted zerocoins (via a Mint).
Validation and block generation. All transactions are veriﬁed via VerifyTransaction when they
are received by a node. Any plain Bitcoin inputs and outputs are processed as usual, and any
Zerocash inputs and outputs are checked using VerifyTransaction with the entire Bitcoin transaction
fed in as info for authentication. Once these transactions are assembled into a candidate block, each
transaction needs to be veriﬁed again to ensure its serial number has not become spent or its Merkle
root invalid. If these checks pass, the set of new coin commitments and spent serial numbers output
by the included transactions are added to the global sets, and the new Merkle root and a digest of
the serial number list is stored in the new block.19 Embedding this data simpliﬁes statekeeping and
allows nodes to readily verify they have the correct coin list and serial number list. Upon receiving
a candidate block, nodes validate the block is formed correctly with respect to the above procedure.
Receiving payments.
In order to receive payments to an address, users may scan the block chain
by running the Receive on every pour transaction. Alternatively they may receive coin information

18Since transaction fees may potentially be claimed by any node in the network, they represent the sole zerocoin

output that cannot be hidden from public view even in a Zerocash-only system.

19This can be stored in the coinbase transaction, as certain other data currently is, or in a new ﬁeld in the block

header.

27

via some out-of-band mechanism (e.g., via encrypted email). The former process is nearly identical
to the one proposed for “stealth addresses” for Bitcoin. In the worst case, scanning the block chain
requires a trial decryption of every ciphertext C. We expect many scenarios to provide explicit
notiﬁcation, e.g., in interactive purchases where a communication channel already exists from the
payer to the payee. (Implementations may opt to drop the receive mechanism entirely, and require
out-of-band notiﬁcation, in order to avoid storing the ciphertexts in the block chain.)

6.3 Extending the Bitcoin protocol to support the combined semantics

While the section above describes the life-cycle of a zerocoin and semantics of the system, there
remains the question of how transactions acquire the above necessary semantics. Two implementation
approaches are possible, with diﬀerent engineering tradeoﬀs.

The ﬁrst approach is to extend the protocol and its implementation with hard-coded validation
of Zerocash transactions, reading them from new, designated ﬁelds in transactions and running
VerifyTransaction. In this case the zk-SNARK itself eﬀectively replaces the scripting language for
Zerocash transactions.

The second approach is to extend Bitcoin’s scripting language by adding an opcode that
invokes VerifyTransaction, with the requisite arguments embeded alongside the opcode script. Such
transactions must be exempt from the requirement they reference an input (as they are Zerocash
transactions are self-contained), and, like coinbase transactions, be able to create bitcoins ex nihilo
(to account for vpub). Moreover, while VerifyTransaction is run at the standard point in the Bitcoin
transaction processing ﬂow for evaluating scripts, the coin commitments and spent serial numbers
are not actually added to CMList (resp., SNList) until their containing block is accepted (i.e., merely
verifying a transaction does not have side eﬀects).

6.4 Additional anonymity considerations

Zerocash only anonymizes the transaction ledger. Network traﬃc used to announce transactions,
retrieve blocks, and contact merchants still leaks identifying information (e.g., IP addresses). Thus
users need some anonymity network to safely use Zerocash. The most obvious way to do this is
via Tor [DMS04]. Given that Zerocash transactions are not low latency themselves, Mixnets (e.g.,
Mixminion [DDM03]) are also a viable way to add anonymity (and one that, unlike Tor, is not as
vulnerable to traﬃc analysis). Using mixnets that provide email-like functionality has the added
beneﬁt of providing an out-of-band notiﬁcation mechanism that can replace Receive.

Additionally, although in theory all users have a single view of the block chain, a powerful
attacker could potentially fabricate an additional block solely for a targeted user. Spending any
coins with respect to the updated Merkle tree in this “poison-pill” block will uniquely identify the
targeted user. To mitigate such attacks, users should check with trusted peers their view of the
block chain and, for sensitive transactions, only spend coins relative to blocks further back in the
ledger (since creating the illusion for multiple blocks is far harder).

7 Experiments

To measure the performance of Zerocash, we ran several experiments. First, we benchmarked the
performance of the zk-SNARK for the NP statement POUR (Section 7.1) and of the six DAP scheme
algorithms (Section 7.2). Second, we studied the impact of a higher block veriﬁcation time via a
simulation of a Bitcoin network (Section 7.3).

28

7.1 Performance of zk-SNARKs for pouring coins

Our zk-SNARK for the NP statement POUR is obtained by constructing an arithmetic circuit CPOUR
for verifying POUR, and then invoking the generic implementation of zk-SNARK for arithmetic
circuit satisﬁability of [BCTV14] (see Section 2.4). The arithmetic circuit CPOUR is built from scratch
and hand-optimized to exploit nondeterministic veriﬁcation and the large ﬁeld characteristic (see
Section 5.2) .

Figure 5 reports performance characteristics of the resulting zk-SNARK for POUR. This includes
three settings: single-thread performance on a laptop machine; and single-thread and multi-thread
performance on a desktop machine. (The time measurements are the average of 10 runs, with
standard deviation under 2.5%.) For instance, with single-thread code on the laptop machine, we
obtain that:
• Key generation takes 7 min 48 s, and results in a proving key pkPOUR of 896 MiB and a veriﬁcation
• Producing a proof πPOUR requires about 3 minutes; proofs have a constant size of 288 B. Proof
generation is a subroutine of the Pour algorithm, and the resulting proof is included in the
corresponding pour transaction.
• A proof πPOUR can be veriﬁed in only 8.5 ms. Proof veriﬁcation is a subroutine of the VerifyTransaction

key vkPOUR of 749 B. This is performed only once, as part of the Setup algorithm.

algorithm, when it is given as input a pour transaction to verify.

Intel

Core i7-2620M

@ 2.70GHz

12GB of RAM

Intel

Core i7-4770
@ 3.40GHz

16GB of RAM

1 thread
7 min 48 s

1 thread
5 min 11 s

4 threads
1 min 47 s

896 MiB

749 B
1 min 59 s
288 B

2 min 55 s

46 s

8.5 ms

5.4 ms

KeyGen Time

Proving key
Veriﬁcation key
Time
Proof
Time

Prove

Verify

Figure 5: Performance of our zk-SNARK for the NP statement POUR. (N = 10, σ ≤ 2.5%)

7.2 Performance of Zerocash algorithms

In Figure 6 we report performance characteristics for each of the six DAP scheme algorithms in
our implementation (single-thread on our desktop machine). For VerifyTransaction, we separately
report the cost of verifying mint and pour transactions and, in the latter case, we exclude the cost
of scanning L (e.g., to check if a serial number is duplicate);20 for the case of Receive, we report the
cost to process a given pour transaction in L.
• Setup takes about 5 minutes to run; its running time is dominated by the running time of KeyGen
on CPOUR. (Either way, Setup is run only once.) The size of the resulting public parameters pp is
dominated by the size of pkPOUR.
• CreateAddress takes 326.0 ms to run. The size of the resulting address key pair is just a few

We obtain that:

hundred bytes.

20Naturally, if SNList has 264 serial numbers (the maximum possible in our implementation), then scanning is very
expensive! However, we do not expect that a system like Zerocash will grow to 264 transactions. Still, such a system
may grow to the point that scanning SNList is too expensive. We detail possible mitigations to this in Section 8.3.2.

29

the latter’s time is dominated by that of Verify, which checks the zk-SNARK proof πPOUR.

• Mint takes 23 µs to run. It results in a coin of size 463 B and mint transaction of size 72 B.
• Pour takes about 2 minutes to run. Besides Setup, it is the only “expensive” algorithm to run; as
expected, its running time is dominated by the running time of Prove. For a transaction string
info, it results in (two new coins and) a pour transaction of size 996 B + |info|.
• VerifyTransaction takes 8.3 µs to verify a mint transaction and 5.7 ms to verify a pour transaction;
• Receive takes 1.6 ms per pour transaction.
Note that the above numbers do not include the costs of maintaining the Merkle tree because
doing so is not the responsibility of the DAP scheme algorithms. Nevertheless, these additional
costs are not large: (i) each update of the root of the CRH-based Merkle tree only requires dtree
invocations of CRH, and (ii) an authentication path consists of only dtree digests of CRH. In our
implementation, where CRH = H (the SHA256 compression function) and dtree = 64, each update
requires 64 invocations of H and an authentication path requires 64 · 32 B = 2 KiB of storage.

Remark. If one does not want to rely on the ledger to communicate coins, via the ciphertexts
C1, C2, and instead rely instead on some out-of-band mechanism (e.g., encrypted email), then the
Receive algorithm is not needed, and moreover, many of the aforementioned sizes decrease because
some pieces of data are not needed anymore; we denoted these pieces of data with “(cid:63)” in Figure 6.
(E.g., the size of an address key pair is reduced to only 64 B, and the size of a coin to only 120 B.)

7.3 Large-scale network simulation

Because Bitcoin mining typically takes place on dedicated GPUs or ASICs, the CPU resources to
execute the DAP scheme algorithms are often of minimal consequence to network performance.
There is one potential exception to this rule: the VerifyTransaction algorithm must be run by all of
the network nodes in the course of routine transaction validation. The time it takes to perform this
veriﬁcation may have signiﬁcant impact on network performance.

In the Zerocash implementation (as in Bitcoin), every Zerocash transaction is veriﬁed at each hop
as it is forwarded though the network and, potentially, again when blocks containing the transaction
are veriﬁed. Verifying a block consists of checking the proof of work and validating the contained
transactions. Thus Zerocash transactions may take longer to spread though the network and blocks
containing Zerocash transactions may take longer to verify. While we are concerned with the ﬁrst
issue, the potential impact of the second issue is cause for greater concern. This is because Zerocash
transactions cannot be spent until they make it onto the ledger.

Because blocks are also veriﬁed at each hop before they are forwarded through the network,
delays in block veriﬁcation slow down the propagation of new blocks through the network. This
causes nodes to waste CPU-cycles mining on out-of-date blocks, reducing the computational power
of the network and making it easier to mount a “51% attack” (dishonest majority of miners) on the
distributed ledger.

It is a priori unclear whether this potential issue is a real concern. Bitcoin caches transaction
veriﬁcations, so a transaction that was already veriﬁed when it propagated through the network need
not be veriﬁed again when it is seen in a block. The unknown is what percentage of transactions in
a block are actually in any given node’s cache. We thus conduct a simulation of the Bitcoin network
to investigate both the time it takes Zerocash transactions to make it onto the ledger and establish
the eﬀects of Zerocash transactions on block veriﬁcation and propagation. We ﬁnd that Zerocash
transactions can be spent reasonably quickly and that the eﬀects of increased block validation time
are minimal.

30

Intel

Core i7-4770
@ 3.40GHz

16GB of RAM

1 thread

5 min 17 s
896 MiB
896 MiB
749 B
0 B
0 B
326.0 ms
343 B
32 B
311 B
319 B
32 B
287 B
23 µs
463 B
343 B
8 B
32 B
48 B
0 B
32 B
72 B
32 B
8 B
32 B
0 B
2 min 2.01 s
996 B + |info|
32 B
2 × 32 B
2 × 32 B
8 B
|info|
66 B
2 × 32 B
288 B
2 × 173 B
64 B
8.3 µs
5.7 ms
1.6 ms

Setup

CreateAddress

Mint

Pour

Time
Size of pp

size of pkPOUR
size of vkPOUR
(cid:63) size of ppenc
size of ppsig

Time
Size of addrpk

size of apk

(cid:63) size of pkenc
Size of addrsk

size of ask

(cid:63) size of skenc
Time
Size of coin c
size of addrpk
size of v
size of ρ
size of r
size of s
size of cm

Size of txMint

size of cm
size of v
size of k
size of s

Time
Size of txPour

, cmnew

2

size of rt
size of snold
1 , snold
2
size of cmnew
1
size of vpub
size of info
size of pksig
size of h1, h2
size of πPOUR

(cid:63) size of C1, C2

size of σ

31

VerifyTransaction Time for mint tx

Receive

Time for pour tx (excludes L scan)
Time (per pour tx)

Figure 6: Performance of Zerocash algorithms. Above, we report the sizes of ppenc and ppsig as 0 B, because
these parameters are “hardcoded” in the libraries we rely on for Enc and Sig. (N = 10 with σ ≤ 2.5% for
all except that, due to variability at short timescales, σ(Mint) ≤ 3.3 µs and σ(VerifyTransaction) ≤ 1.9 µs)

Simulation design. Because Zerocash requires breaking changes to the Bitcoin protocol, we
cannot test our protocol in the live Bitcoin network or even in the dedicated testnet. We must run
our own private testnet. For eﬃciency and cost reasons, we would like to run as many Bitcoin nodes
as possible on the least amount of hardware. This raises two issues. First, reducing the proof of
work to practical levels while still preserving a realistic rate of new blocks is diﬃcult (especially on

virtualized hardware with variable performance). Second, the overhead of zk-SNARK veriﬁcation
prevents us from running many Bitcoin nodes on one virtualized server.

The frequency of new blocks can be modeled as a Poisson process with a mean of Λblock seconds.21
To generate blocks stochastically, we modify bitcoind to ﬁx its block diﬃculty at a trivial level 22
and run a Poisson process, on the simulation control server, which trivially mines a block on a
randomly selected node. This preserves the distribution of blocks, without the computational
overhead of a real proof of work. Another Poisson process triggering mechanism, with a diﬀerent
mean Λtx, introduces new transactions at random network nodes.

To diﬀerentiate which transactions represent normal Bitcoin expenditures versus which contain
Zerocash pour transactions, simulated Zerocash transactions pay a unique amount of bitcoins (we
set this value arbitrarily at 7 BTC). If a transaction’s output matches this preset value, and it is not
in veriﬁcation cache, then our modiﬁed Bitcoin client inserts a 10 ms delay simulating the runtime
of VerifyTransaction.23 Otherwise transactions are processed as speciﬁed by the Bitcoin protocol.
We vary the amount of simulated Zerocash traﬃc by varying the number of transactions with this
particular output amount. This minimizes code changes and estimates only the generic impact of
veriﬁcation delays and not of any speciﬁc implementation choice.

Methodology. Recent research [DW13] suggests that the Bitcoin network contains 16,000 distinct
nodes though most are likely no longer participating: approximately 3,500 are reachable at any
given time. Each node has an average of 32 open connections to randomly selected peers. As of
November 2013, the peak observed transaction rate for Bitcoin is slightly under one transaction per
second [Lee13].

In our simulation, we use a 1000-node network in which each node has an average of 32 peers,
transactions are generated with a mean of Λtx = 1 s, a duration of 1 hour, and a variable percentage
(cid:15) of Zerocash traﬃc. To allow for faster experiments, instead of generating a block every 10 minutes
as in Bitcoin, we create blocks at an average of every Λblock = 150 s (as in Litecoin, a popular
altcoin).
We run our simulation for diﬀerent traﬃc mixes, where (cid:15) indicates the percentage of Zerocash
transactions and (cid:15) ∈ {0%, 25%, 50%, 75%, 100%}. Each simulation is run on 200 Amazon EC2
general-purpose m1.medium instances, in one region on a 10.10./16 private network. On each
instance, we deploy 5 instances of bitcoind.24
Results. Transactions are triggered by a blocking function call on the simulation control node
that must connect to a random node and wait for it to complete sending a transaction. Because
the Poisson process modeling transactions generates delays between such calls and not between the
exact points when the node actuals sends the transactions, the actual transaction rate is skewed.
In our experiments the real transaction rate shifts away from our target of one per second to an
average of one every 1.4 seconds.
In Figure 7 we plot three metrics for (cid:15) ∈ {0%, 25%, 50%, 75%, 100%}. Each is the average
deﬁned over the data from the entire run of the simulation for a given (cid:15) (i.e., they include multiple
transactions and blocks).25 Transaction latency is the interval between a transaction’s creation and

21Since computational power is added to the Bitcoin network faster than the 2-week diﬃculty adjustment period,

the frequency of block generation is actually skewed. As our experiments run for at most an hour, we ignore this.

22These code modiﬁcations have been rendered moot by the subsequent inclusion of a “regtest” mode in Bitcoin 0.9
that allows for precisely this type of behavior and block generation on command. At the time of our experiments, this
feature was not available in a stable release. Future work should use this feature.

23We used a generous delay of 10 ms (higher than the time reported in Figure 6) to leave room for machines slower

than our desktop machine.

24Higher densities of nodes per VM resulted in issues initializing all of the bitcoind instances on boot.
25Because our simulated Bitcoin nodes ran on shared EC2 instances, they were subject to variable external load,

32

its inclusion in a block. Block propagation time comes in two ﬂavors: (1) the average time for a new
block to reach a node computed over the times for all nodes, and (2) the same average computed
over only the last node to see the block.

Block veriﬁcation time is the average time, over all nodes, required to verify a block. If veriﬁcation
caching was not eﬀective, we would expect to see a marked increase in both block veriﬁcation time
and propagation time. Since blocks occur on average every 150 s, and we expect approximately
one transaction each second, we should see 150 × 10 ms = 1500 ms of delay if all transactions were
non-cached Zerocash transactions. Instead, we see worst case 80 ms and conclude caching is eﬀective.
This results in a negligible eﬀect on block propagation (likely because network operations dominate).
The time needed for a transaction to be conﬁrmed, and hence spendable, is roughly 190 s. For
slower block generation rates (e.g., Bitcoin’s block every 10 minutes) this should mean users must
wait only one block before spending received transactions.

(a) Transaction latency

(b) Block propagation time

(c) Block veriﬁcation time

Figure 7: The average values of the three metrics we study, as a function of (cid:15), the percentage of transactions
that are Zerocash transactions. Note that, in (a), latency is undeﬁned when (cid:15) = 0 and hence omitted.

8 Optimizations and extensions

We outline several optimizations and extensions to Zerocash: everlasting anonymity (Section 8.1),
faster block propagation (Section 8.2), and improved storage requirements (Section 8.3).

8.1 Everlasting anonymity

Since transactions may persist virtually forever on the ledger, users may wish to ensure the
anonymity of their transactions also lasts forever, even if particular primitives are eventually broken
(by cryptanalytic breakthrough, engineering progress, or quantum computers). As we now explain,
the DAP scheme construction described in Section 4 is only computationally private, but can be
modiﬁed to achieve everlasting anonymity.
vpub, info,∗), where ∗ = (pksig, h1, h2, πPOUR, C1, C2, σ) and Ci = Eenc(pknew
Observe that:

Recall that every Pour operation publishes a pour transaction txPour = (rt, snold
1 , snold
2 , cmnew
, rnew
, ρnew
enc,i, (vnew
i
i

, cmnew
,
2
, snew
)).

1

i

i

limiting the benchmark precision. Still, it clearly demonstrates that the mild additional delay does not cause
catastrophic network eﬀects.

33

 0 20 40 60 80 100 120 140 160 180 2000%20%40%60%80%100%time in secondsεZerocash 0 0.5 1 1.5 2 2.5 3 3.5 4 4.50%20%40%60%80%100%time in secondsεlast nodeevery node 0 10 20 30 40 50 60 70 800%20%40%60%80%100%time in millisecondsεZerocashaold
sk,i

until PRFpk
case it equals aold

• Since hSig = CRH(pksig) and hi = PRFpk

(hSig), an unbounded adversary A can iterate over all x
x (hSig) equals hi; with overwhelming probability, there is only one such x, in which
(0). This identiﬁes the sender.
); then, A can try all
; with overwhelming
sk,i . This identiﬁes the recipient.

possible x until COMMsnew
probability, there is only one such x, in which case it equals anew

• An unbounded A can also decrypt Ci, so to learn (vnew

sk,i. Thus, A learns aold

i
)) equals cmnew

sk,i, and hence aold

pk,i := PRFaddr
aold
sk,i

(cid:107)COMMrnew

(0)(cid:107)ρnew

(PRFaddr

, ρnew

, rnew

, snew

(vnew

x

i

i

i

i

i

i

i

i

The above attacks can be prevented as follows. First, every sender must use any given address
only once (for receiving or sending coins): after receiving a coin c, a user u should immediately
generate a new address and pour c into a fresh one c(cid:48) relative to the new address; only afterwards
can u spend the coin. Second, a user should not put any data in a ciphertext Ci to communicate
a coin’s information, but must instead use some (informationally-secure) out-of-band channel to
do so. With these modiﬁcations (and recalling that COMM is statistically hiding and πPOUR is a
perfect-zero-knowledge proof), one can verify that the pour transaction txPour is statistically hiding,
i.e., leaks no information even to unbounded adversaries.26

8.2 Fast block propagation

As mentioned in Section 7.3, the higher block-veriﬁcation time of Zerocash compared to, e.g., Bitcoin
does not aﬀect much block propagation. Even so, we note a simple modiﬁcation that further mitigates
concerns. Upon receiving a block, a node validates the proof of work and (optionally) transactions
other than mint and pour, and then forward the block right away. Only afterwards, the node
executes VerifyTransaction on any mint/pour transactions, before accepting it for use in transacting.
Thus, blocks are still validated by every node (so the security properties are unhampered), and
propagation delays in the broadcast of blocks are reduced.

In principle, this opens the possibility of a denial-of-service attack, in which the network is
spammed with invalid blocks which pass the proof-of-work check but contain invalid mint or pour
transactions. However, this attack appears unrealistic given the enormous (by design) cost of
creating blocks passing the proof-of-work check.

8.3 Improved storage requirements

Beyond the ledger L, users need to maintain two lists: CMList, the list of all coin commitments,
and SNList, the list of all serial numbers of spent coins (see Section 3.1). In our construction,
CMList is required to deduce authentication paths to create new pour transactions (via Pour), while
SNList is used to verify pour transactions (via VerifyTransaction). As the ledger grows, both CMList
and SNList grow in size, and can eventually impose substantial storage requirements (though both
are derived from, and smaller than, the block chain per se). We now explain how these storage
requirements can be mitigated, by relying on smaller representations of CMList and SNList that
suﬃce within our construction.

8.3.1 Supporting many coin commitments

To execute the Pour algorithm to spend a coin c, a user u needs to provide an authentication path
from c’s coin commitment to rt, the Merkle-tree root over CMList. If we make the following protocol
modiﬁcations, u does not need all of CMList to compute this authentication path.

26As for mint transactions, one can verify that they are already statistically hiding, without any modiﬁcations.

34

In each block B of transactions, we store the Merkle-tree path pathB from the ﬁrst coin
commitment in B to the root rtB of the Merkle tree over CMList when the last block in the ledger
is B. (In Zerocash, the additional per-block storage cost to store this information is only 2 KiB.)
Note that, given a block B and its successor block B(cid:48), the corresponding authentication paths
pathB and pathB(cid:48) can be easily checked for consistency as follows. Let CMListB and CMListB(cid:48) be
the two lists of coin commitments corresponding to the two ledgers ending in block B and B(cid:48)
respectively; since CMListB (i.e., coin commitments to “to the left” of pathB) is a preﬁx of CMListB(cid:48),
pathB(cid:48) can be computed from pathB and B in time O(|B|dtree), where dtree is the tree depth.

When the user u ﬁrst receives (or mints) the coin c, and its coin commitment is included in a
block B, u immediately computes pathB, by using the predecessor block and its authentication path.
Afterwards, each time a new block is added to the ledger, u obtains a new path for c by using the
new block and the old path for c. Thus, u only needs to act each time a new block is added, and
each such update costs O(dtree) per transaction in the block.

Overall, u incurs a storage requirement of only O(dtree) for each coin he owns, and does not

need to store CMList anymore.

8.3.2 Supporting many spent serial numbers

To execute the VerifyTransaction algorithm on a pour transaction txPour, a user u needs access to
SNList (in order to check for duplicate serial numbers). Note, in Bitcoin, nodes need to maintain
only the list of unspent transaction outputs, which is pruned as outputs are spent. In a DAP scheme,
in contrast, nodes have to maintain SNList, which is a list that always grows. We now explain how
to mitigate this storage requirement, in three incremental steps.

Step 1. The ﬁrst step is to build a Merkle tree over SNList so to allow easy-to-verify non-membership
proofs for SNList; this can be done by letting the leaves of the Merkle tree be the intervals of unspent
serial numbers. Then, given the root rt of such tree, a serial number sn claimed to be unspent, and
an authentication path path for an interval I, the user can check that path is valid for rt and that
sn lies in I; the root rt and path path would be part of the pour transaction txPour to be veriﬁed.
The problem with this approach, however, is that generating path (and also updating rt) requires
knowledge of all of SNList.

Step 2. Next, instead of maintaining SNList in a single Merkle tree, we divide SNList, maintaining
its chronological order, into sublists of serial numbers SNList0, SNList1, . . . and build a Merkle tree
over the intervals induced by each sublist (i.e., apply Step 1 to each sublist). This modiﬁcation
implies a corresponding modiﬁcation for the auxiliary information stored in a pour transaction
that allows VerifyTransaction to check it. Now, however, producing such auxiliary information
is less expensive.
Indeed, a user with a coin c should maintain a list of authentication paths
pathc,0, pathc,1, . . . (one for each sublist). Only the last path, corresponding to the active sublist,
needs to be updated when a serial number is added; the other sublists and authentication paths
remain unchanged (and these old sublists can in fact be discarded). When the user spends the coin,
he can simply include these paths in the pour transaction. While updating these paths is an eﬃcient
operation, computing the initial paths for c is not, as it still requires the full set of sublists.

Step 3. To enable users to avoid the initial cost of computing paths for a new coin, we proceed
as follows. First, a coin c is extended to contain a time stamp Tc corresponding to when c is
created (minted or poured into); the coin’s commitment is modiﬁed to depend on the timestamp,
and the timestamp is included in the clear within the transaction that creates the coin. Then, a
user, upon spending c, produces a zk-SNARK for the following NP statement: “for each Merkle-tree
root created (or updated) after Tc there is an interval and an authentication path for that interval

35

such that the serial number of c is in that interval”. Depending on the number of Merkle trees in
such an NP statement, such proofs may already be more eﬃcient to produce, compared to the naive
(Step 1) solution, using existing zk-SNARK implementations.

9 Concurrent work

Danezis et al. [DFKP13] suggest using zk-SNARKs to reduce proof size and veriﬁcation time in
Zerocoin. Our work diﬀers from [DFKP13] in both supported functionality and scalability.

First, [DFKP13]’s protocol, like Zerocoin, only supports ﬁxed-value coins, and is best viewed
as a decentralized mix. Instead, we deﬁne, construct, and implement a full-ﬂedged decentralized
electronic currency, which provides anonymous payments of any amount.

Second, in [DFKP13], the complexity of the zk-SNARK generator, prover, and veriﬁer all scale
superlinearly in the number of coins, because their arithmetic circuit computes, explicitly, a product
over all coins. In particular, the number of coins “mixed together” for anonymity cannot be large.
Instead, in our construction, the respective complexities are polylogarithmic, polylogarithmic, and
constant in the number of coins; our approach supports a practically-unbounded number of coins.
While we do not rely on Pedersen commitments, our approach also yields statistical (i.e.,

everlasting) anonymity; see the discussion in Section 8.1.

10 Conclusion

Decentralized currencies should ensure a user’s privacy from his peers when conducting legitimate
ﬁnancial transactions. Zerocash provides such privacy protection, by hiding user identities, trans-
action amounts, and account balances from public view. This, however, may be criticized for
hampering accountability, regulation, and oversight. Yet Zerocash need not be limited to enforcing
the basic monetary invariants of a currency system. The underlying zk-SNARK cryptographic proof
machinery is ﬂexible enough to support a wide range of policies. It can, for example, let a user prove
that he paid his due taxes on all transactions without revealing those transactions, their amounts, or
even the amount of taxes paid. As long as the policy can be speciﬁed by eﬃcient nondeterministic
computation using NP statements, it can (in principle) be enforced using zk-SNARKs, and added
to Zerocash. This can enable automated, privacy-preserving veriﬁcation and enforcement of a wide
range of compliance and regulatory policies that would otherwise be invasive to check directly or
might be bypassed by corrupt authorities. This raises research, policy, and engineering questions
regarding which such policies are desirable and practically realizable.

Another research question is what new functionality can be realized by augmenting the capabilities
already present in Bitcoin’s scripting language with zk-SNARKs that allow fast veriﬁcation of
expressive statements.

36

Acknowledgments

We thank Amazon for their assistance and kind donation of EC2 resources, and Gregory Maxwell for
his advice regarding the Bitcoin codebase. We thank Iddo Ben-Tov and the SCIPR Lab members
— Daniel Genkin, Lior Greenblatt, Shaul Kﬁr, Gil Timnat, and Michael Riabzev — for inspiring
discussions. We thank Sharon Kessler for editorial advice.

This work was supported by: Amazon.com through an AWS in Education research grant; the
Broadcom Foundation and Tel Aviv University Authentication Initiative; the Center for Science of
Information (CSoI), an NSF Science and Technology Center, under grant agreement CCF-0939370;
the Check Point Institute for Information Security; the U.S. Defense Advanced Research Projects
Agency (DARPA) and the Air Force Research Laboratory (AFRL) under contract FA8750-11-2-0211;
the European Community’s Seventh Framework Programme (FP7/2007-2013) under grant agreement
number 240258; the Israeli Centers of Research Excellence I-CORE program (center 4/11); the Israeli
Ministry of Science and Technology; the Oﬃce of Naval Research under contract N00014-11-1-0470;
the Simons Foundation, with a Simons Award for Graduate Students in Theoretical Computer
Science; and the Skolkovo Foundation with agreement dated 10/26/2011.

The views expressed are those of the authors and do not reﬂect the oﬃcial policy or position of the
Department of Defense or the U.S. Government.

37

A Overview of Bitcoin and Zerocoin

We provide an overview of the Bitcoin and Zerocoin protocols. For more details, we refer the reader
to Nakamoto [Nak09] and Miers et al. [MGGR13] respectively.

A.1 Bitcoin

Bitcoin [Nak09] is a decentralized currency operated by a collection of mutually-distrusting peers.
It consists of three basic components: (i) a peer-to-peer network for broadcasting new transactions;
(ii) semantics for identifying and validating new transactions; and (iii) a protocol for maintaining a
decentralized ledger, known as the block chain, that stores the history of all valid transactions so far.
Identities in Bitcoin are represented via ECDSA public keys. Each user u generates an ECDSA
key pair (vku, sku) and, to receive payments, publishes the veriﬁcation key vku (or its hash) as an
address. (In fact, there is no limit to the number of addresses that an individual user may possess.)

Transactions. A transaction tx represents a payment from a list of input transactions to a list of
output recipients. More precisely, tx is speciﬁed by a list {Ij}j of inputs and a list {Oj}j of outputs.
Each output Oj speciﬁes a value vj, denominated in Satoshi (109 Satoshi amounts to 1 bitcoin), and
a recipient speciﬁcation rj, called ScriptPubKey. The speciﬁcation rj is given in Bitcoin script, a
stack-based non-Turing-complete language similar to Forth, and speciﬁes the identity of the recipient
of the vj Satoshi. Each input Ij references an output of a previous transaction txj: the reference is
speciﬁed by a tuple (hj, kj, σj), where hj is the hash of txj, kj is an index specifying which output of
txj is referenced, and σj, called ScriptSig, is a an input satisfying the ScriptPubKey of the kj-th
output of txj. Typically, the ScriptPubKey speciﬁes a public key that must sign the transaction
spending the output and σj contains such a signature, hence their names. Inputs can only be
claimed by one transaction to prevent double spending.

The total number of bitcoins output by a transaction,(cid:80)

j vj, cannot exceed the total value of
the referenced outputs. Any diﬀerence between these two quantities is claimed as a transaction fee
(see below). Thus, any unspent inputs to a transaction become a fee, and transactions typically
have at least two outputs: one to the payment’s recipient and one back to the sender as “change”.

The block chain. Transactions are broadcast in the Bitcoin peer-to-peer network, but are
considered valid only once they have been added to the the block chain. To assemble the block
chain, miners (usually but not necessarily, network nodes) collect transactions from the Bitcoin
network and bundle them into blocks. Miners then compete for the opportunity to append their
own candidate block B to the block chain by searching for a string s such that the integer speciﬁed
by SHA256(SHA256(B(cid:107)s)) is below some threshold. To incentivize block creation, miners receive
a protocol-speciﬁed reward (currently 25 BTC) for adding a new block and, moreover, receive
per-transaction fees (whose value is speciﬁed by the transaction’s creator).

The proof of work protects a block against tampering and also ensures that meaningful compu-
tational resources were devoted to ﬁnding it. This prevents a sybil attack since all the sybils share
the same total computational resources (e.g., the server they are virtualized on). Bitcoin assumes
that provided more than half the computational work is held by honest nodes, the block-chain is
secure. (Though recent work [ES13] has suggested that the threshold may be larger than 50%.)

A.2 Zerocoin

Zerocoin extends Bitcoin by creating two new transaction types: mint and spend. A mint transaction
allows a user to exchange a quantity of bitcoins for the right to mint a new zerocoin. Each zerocoin
consists of a digital commitment cm to a random serial number sn. At a later point, a (potentially

38

diﬀerent) user may issue a spend transaction containing a destination identity, the serial number
sn, and a non-interactive zero-knowledge proof for the NP statement “I know secret cm and r
such that (i) cm can be opened to sn with commitment randomness r, and (ii) cm was previously
minted at some point in the past”. Crucially, the proof, being zero knowledge, does not link the
spend transaction to any particular mint transaction (among all mint transactions so far). If the
proof veriﬁes correctly and the serial number has not been spent previously, the protocol semantics
transfer a corresponding amount of bitcoins to the destination address. In this fashion, Zerocoin
functions as a decentralized mix.
Zerocoin uses Pedersen commitments over a prime ﬁeld Fp, i.e., cm := gsnhr, for random
generators g, h of a subgroup of F∗
p. The corresponding zero-knowledge proofs are constructed
by ﬁrst accumulating (via the Strong-RSA accumulator of [CL01]) the set of commitments of all
minted zerocoins, and then proving knowledge of the corresponding commitment randomness and
membership in this set. For technical reasons, the proof requires a double-discrete-logarithm (DDL)
Fiat–Shamir proof of size ≈ |p|λ, where λ is the security parameter. In practice, the size of these
proofs exceeds 45 kB at the 128-bit security level, and require 450 ms or more to verify.

Also note that, in Zerocoin, computing the witness for the accumulator requires access to
the entire set of commitments so far (though the witness can be incrementally updated for each
insertion). This technique supports an unlimited number of coins. In contrast, our construction
places a cap N on the number of coins (in our implementation, N = 264) but needs only log N
updates to issue N new coins (and these updates can be eﬃciently batched, cf. Section 8.3.1).

B Completeness of DAP schemes

A DAP scheme Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) is complete if no
polynomial-size ledger sampler S can win the incompleteness experiment with more than negligible
probability. In Section 3.4 we informally described this property; we now formally deﬁne it.

Deﬁnition B.1. Let Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candi-
date) DAP scheme. We say that Π is complete if, for every poly(λ)-size ledger sampler S and
suﬃciently large λ,

AdvINCOMP

Π,S

(λ) < negl(λ) ,

where AdvINCOMP

Π,S

(λ) := Pr[INCOMP(Π,S, λ) = 1] is S’s advantage in the incompleteness experiment.

We now describe the incompleteness experiment mentioned above. Given a (candidate)
DAP scheme Π, a ledger sampler S, and a security parameter λ, the (probabilistic) experiment
INCOMP(Π,S, λ) consists of an interaction between S and a challenger C, terminating with a binary
output by C.
At the beginning of the experiment, C samples pp ← Setup(1λ) and sends pp to S. Then, S
sends C a ledger, two coins to be spent, and parameters for a pour transaction; more precisely, S
sends (1) a ledger L; (2) two coins cold
sk,2; (4) two
values vnew
sk,2); (6) a public value
vpub; and (7) a transaction string info. Afterwards, C performs various checks on S’s message.

Concretely, C ﬁrst checks that cold
2 are well-formed; (ii) their coin commitments cmold

2 are valid unspent coins, i.e., checks that: (i) cold
1
2 appear in (valid) transactions
2 do not appear in (valid) transactions on L. Next, C
(i.e., the values suggested by S preserve balance) and
2 ≤ vmax (i.e., the maximum value is not exceeded). If any of these checks fail, C aborts

and cold
on L; (iii) their serial numbers snold
checks that vnew
2 + vpub = vold
vold
1 + vold
and outputs 0.

2 ; (3) two address secret keys addrold

; (5) new address key pairs (addrnew

1 and snold
1 + vold
2

sk,1), (addrnew

1 and cmold

pk,1, addrnew

pk,2, addrnew

1 and cold

sk,1, addrold

1 + vnew

1 , cold

, vnew

2

1

39

Otherwise, C computes rt, the Merkle-tree root over all coin commitments in L (appearing in
to

valid transactions), and, for i ∈ {1, 2,}, pathi, the authentication path from commitment cmold
the root rt. Then, C attempts to spend cold

i

1 , cold

2 as instructed by S:
sk,2, path1, path2, vnew

1

2

, txPour) ← Pour(pp, rt, cold

, cnew

1 , cold

2 , addrold

sk,1, addrold

(cnew
, vnew
Finally, C outputs 1 if and only if any of the following conditions hold:
• txPour (cid:54)= (rt, snold
, cmnew
; OR
• txPour is not valid, i.e., VerifyTransaction(pp, txPour, L) outputs 0; OR
• for some i ∈ {1, 2}, the coin cnew

, vpub, info,∗), where cmnew

is not returned by Receive(pp, (addrnew

2 , cmnew

1 , snold

, cmnew

of cnew

, cnew

2

1

2

1

2

1

1

2

i

is the ledger obtained by appending txPour to L.

, addrnew

pk,1, addrnew

pk,2, vpub, info) .

are the coin commitments

pk,i, addrnew

sk,i ), L(cid:48)), where L(cid:48)

Remark. There is no need for the challenger C check that, in turn, both cnew
are spendable,
2 were not spendable, a diﬀerent sampler S(cid:48)
because this follows by induction. Namely, if cnew
, cnew
(that simulates S and then computes and outputs cnew
) would provide a counterexample
to the above deﬁnition.

and cnew

and cnew

1

2

1

2

1

C Security of DAP schemes

A DAP scheme Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) is secure if it satis-
ﬁes ledger indistinguishability, transaction non-malleability, and balance. (See Deﬁnition 3.2.) In
Section 3.4 we informally described these three properties; we now formally deﬁne them.
Each of the deﬁnitions employs an experiment involving a (stateful) DAP oracle ODAP that
receives and answers queries from an adversary A (proxied via a challenger C, which performs the
experiment-speciﬁc sanity checks). Below, we ﬁrst describe how ODAP works.
The oracle ODAP is initialized by a list of public parameters pp and maintains state. Internally,
ODAP stores: (i) L, a ledger; (ii) ADDR, a set of address key pairs; (iii) COIN, a set of coins. All of
L, ADDR, COIN start out empty. The oracle ODAP accepts diﬀerent types of queries, and each query
causes diﬀerent updates to L, ADDR, COIN and outputs. We now describe each type of query Q.
• Q = (CreateAddress)

1. Compute (addrpk, addrsk) := CreateAddress(pp).
2. Add the address key pair (addrpk, addrsk) to ADDR.
3. Output the address public key addrpk.
The ledger L and coin set COIN remain unchanged.

• Q = (Mint, v, addrpk)

1. Compute (c, txMint) := Mint(pp, v, addrpk).
2. Add the coin c to COIN.
3. Add the mint transaction txMint to L.
4. Output ⊥.
The address set ADDR remains unchanged.

• Q = (Pour, idxold

1 , idxold

pk,1, addrnew
1. Compute rt, the root of a Merkle tree over all coin commitments in L.
2. For each i ∈ {1, 2}:

pk,2, info, vnew

pk,1, addrold

2 , addrold

, addrnew

, vnew

2

1

pk,2, vpub)

(a) Let cmold

i be the idxold
i

-th coin commitment in L.

40

(b) Let txi be the mint/pour transaction in L that contains cmold
.
i be the ﬁrst coin in COIN with coin commitment cmold
(c) Let cold
.
sk,i) be the ﬁrst key pair in ADDR with addrold
(d) Let (addrold
pk,i being cold
(e) Compute pathi, the authentication path from cmold

pk,i, addrold

i

i

i

i

’s address.

, cnew

, txPour) := Pour(pp, rt, cold

1 , cold

2 , addrold

sk,2, path1, path2, vnew

1

, vnew

,

2

to rt.
sk,1, addrold

3. Compute (cnew
pk,1, addrnew

addrnew

2

1
pk,2, vpub, info).

1

4. Verify that VerifyTransaction(pp, txPour, L) outputs 1.
5. Add the coin cnew
6. Add the coin cnew
7. Add the pour transaction txPour to L.
8. Output ⊥.
If any of the above operations fail, the output is ⊥ (and L, ADDR, COIN remain unchanged).

to COIN.
to COIN.

2

• Q = (Receive, addrpk)

1. Look up (addrpk, addrsk) in ADDR. (If no such key pair is found, abort.)
2. Compute (c1, . . . , cn) ← Receive(pp, (addrpk, addrsk), L).
3. Add c1, . . . , cn to COIN.
4. Output (cm1, . . . , cmn), the corresponding coin commitments.
The ledger L and address set ADDR remain unchanged.

• Q = (Insert, tx)

1. Verify that VerifyTransaction(pp, tx, L) outputs 1. (Else, abort.)
2. Add the mint/pour transaction tx to L.
3. Run Receive for all addresses addrpk in ADDR; this updates the COIN with any coins that
4. Output ⊥.
The address set ADDR remains unchanged.

might have been sent to honest parties via tx.

Remark. The oracle ODAP provides A with two ways to cause a pour transaction to be added to L.
If A has already obtained address public keys addrpk,1 and addrpk,2 (via previous CreateAddress
queries), then A can use a Pour query to elicit a pour transaction txPour (despite not knowing
address secret keys addrsk,1, addrsk,2 corresponding to addrpk,1, addrpk,2). Alternatively, if A has
himself generated both address public keys, then A knows corresponding address secret keys, and
can invoke Pour “in his head” to obtain a pour transaction txPour, which he can add to L by using
an Insert query. In the ﬁrst case, both addresses belong to honest users; in the second, both to A.
But what about pour transactions where one address belongs to an honest user and one to A?
Such pour transactions might arise from MPC computations (e.g., to make matching donations).
The ledger oracle ODAP, as deﬁned above, does not support such queries. While extending the
deﬁnition is straightforward, for simplicity we leave handling such queries to future work.

C.1 Ledger indistinguishability

Ledger indistinguishability is characterized by an experiment L-IND, which involves a polynomial-size
adversary A attempting to break a given (candidate) DAP scheme.
Deﬁnition C.1. Let Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candi-
date) DAP scheme. We say that Π is L-IND secure if, for every poly(λ)-size adversary A and
suﬃciently large λ,

AdvL-IND

Π,A (λ) < negl(λ) ,

41

where AdvL-IND

Π,A (λ) := 2 · Pr[L-IND(Π,A, λ) = 1] − 1 is A’s advantage in the L-IND experiment.

We now describe the L-IND experiment mentioned above. Given a (candidate) DAP scheme Π,
adversary A, and security parameter λ, the (probabilistic) experiment L-IND(Π,A, λ) consists of an
interaction between A and a challenger C, terminating with a binary output by C.
At the beginning of the experiment, C samples b ∈ {0, 1} at random, samples pp ← Setup(1λ),
and sends pp to A; next, C initializes (using pp) two separate DAP oracles ODAP
(i.e.,
the two oracles have separate ledgers and internal tables).
The experiment proceeds in steps and, at each step, C provides to A two ledgers (LLeft, LRight),
where LLeft := Lb is the current ledger in ODAP
1−b ; then A sends
to C a pair of queries (Q, Q(cid:48)), which must be of the same type (i.e., one of CreateAddress, Mint,
Pour, Receive, Insert). The challenger C acts diﬀerently depending on the query type, as follows.
• If the query type is Insert, C forwards Q to ODAP
1−b . This allows A to insert his
own transactions directly in LLeft and LRight.
• For any other query type, C ﬁrst ensures that Q, Q(cid:48) are publicly consistent (see below) and then
; letting (a0, a1) be the two oracle answers, C replies to A
forwards Q to ODAP
with (ab, a1−b). This allows A to elicit behavior from honest users. However note that A does not
know the bit b, and hence the mapping between (LLeft, LRight) and (L0, L1); in other words, A
does not know if he elicits behavior on (L0, L1) or on (L1, L0).
At the end of the experiment, A sends C a guess b(cid:48) ∈ {0, 1}. If b = b(cid:48), C outputs 1; else, C outputs 0.

and LRight := L1−b the one in ODAP

, and Q(cid:48) to ODAP

, and Q(cid:48) to ODAP

and ODAP

0

1

1

0

b

b

1 , idxold

2 ) must correspond to coins cold

Public consistency. As mentioned above, A sends C pairs of queries (Q, Q(cid:48)), which must be
of the same type and publicly consistent, a property that we now deﬁne. If Q, Q(cid:48) are both of
type CreateAddress or Receive, then they are always publicly consistent. In the special case of
CreateAddress we require that both oracles generate the same address. If they are both of type
Mint, then the minted value in Q must equal that in Q(cid:48). Finally, if they are both of type Pour,
the following restrictions apply.
First, Q, Q(cid:48) must be individually well-formed; namely, (i) the coin commitments referenced by
Q (via the two indices idxold
that appear in the ledger
oracle’s coin table COIN; (ii) the two coins cold
2 must be unspent (i.e. their serial numbers must
not appear in a valid pour transactions on the corresponding oracle’s ledger); (iii) the address public
keys speciﬁed in Q must match those in cold
2 ; and (iv) the balance equation must hold (i.e.,
vnew
1 + vnew
Furthermore, Q, Q(cid:48) must be jointly consistent with respect to public information and A’s view;
namely: (i) the public values in Q and Q(cid:48) must equal; (ii) the transaction strings in Q and Q(cid:48) must
equal; (iii) for each i ∈ {1, 2}, if the i-th recipient addresses in Q is not in ADDR (i.e., belongs to A)
in both Q and Q(cid:48) must equal (and vice versa for Q(cid:48)); and (iv) for each i ∈ {1, 2}, if the
then vnew
i-th index in Q references (in L0) a coin commitment contained in a transaction that was posted via
an Insert query, then the corresponding index in Q(cid:48) must reference (in L1) a coin commitment that
in both Q and Q(cid:48) must
also appears in a transaction posted via an Insert query and, moreover, vold
equal (and vice versa for Q(cid:48)). The challenger C learns vold
by looking-up the corresponding coin cold
in the oracle’s coin set COIN. (v) for each i ∈ {1, 2} if the i-th index in Q must not reference a coin
that has previously been spent.

2 + vpub = vold

1 + vold

1 , cold
2

1 , cold

1 , cold

2 ).

i

i

i

i

C.2 Transaction non-malleability

Transaction non-malleability is characterized by an experiment TR-NM, which involves a polynomial-
size adversary A attempting to break a given (candidate) DAP scheme.

42

Deﬁnition C.2. Let Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (candi-
date) DAP scheme. We say that Π is TR-NM secure if, for every poly(λ)-size adversary A and
suﬃciently large λ,

AdvTR-NM

Π,A (λ) < negl(λ) ,

where AdvTR-NM

Π,A (λ) := Pr[TR-NM(Π,A, λ) = 1] is A’s advantage in the TR-NM experiment.

We now describe the TR-NM experiment mentioned above. Given a (candidate) DAP scheme Π,
adversary A, and security parameter λ, the (probabilistic) experiment TR-NM(Π,A, λ) consists of
an interaction between A and a challenger C, terminating with a binary output by C.
At the beginning of the experiment, C samples pp ← Setup(1λ) and sends pp to A; next, C
initializes a DAP oracle ODAP with pp and allows A to issue queries to ODAP. At the end of the
experiment, A sends C a pour transaction tx∗, and C outputs 1 if and only if the following conditions
hold. Letting T be the set of pour transactions generated by ODAP in response to Pour queries,
there exists tx ∈ T such that: (i) tx∗ (cid:54)= tx; (ii) VerifyTransaction(pp, tx∗, L(cid:48)) = 1, where L(cid:48) is the
portion of the ledger preceding tx;27 and (iii) a serial number revealed in tx∗ is also revealed in tx.

C.3 Balance
Balance is characterized by an experiment BAL, which involves a polynomial-size adversary A
attempting to break a given (candidate) DAP scheme.

Deﬁnition C.3. Let Π = (Setup, CreateAddress, Mint, Pour, VerifyTransaction, Receive) be a (can-
didate) DAP scheme. We say that Π is BAL secure if, for every poly(λ)-size adversary A and
suﬃciently large λ,

where AdvBAL

Π,A(λ) := Pr[BAL(Π,A, λ) = 1] is A’s advantage in the BAL experiment.

AdvBAL

Π,A(λ) < negl(λ) ,

We now describe the BAL experiment mentioned above. Given a (candidate) DAP scheme Π,
adversary A, and security parameter λ, the (probabilistic) experiment BAL(Π,A, λ) consists of an
interaction between A and a challenger C, terminating with a binary output by C.
At the beginning of the experiment, C samples pp ← Setup(1λ), and sends pp to A; next, C
(using pp) initializes a DAP oracle ODAP and allows A to issue queries to ODAP. At the conclusion
of the experiment, A sends C a set of coins Scoin. Recalling that ADDR is the set of addresses
returned by CreateAddress queries (i.e., addresses of “honest” users), C computes the following
ﬁve quantities.
• vUnspent, the total value of all spendable coins in Scoin. The challenger C can check if a coin
c ∈ Scoin is spendable as follows: mint a fresh coin c(cid:48) of value 0 (via a Mint query) and check if
a corresponding Pour query consuming c, c(cid:48) yields a pour transaction txPour that is valid.

• vMint, the total value of all coins minted by A. To compute vMint, the challenger C sums up
the values of all coins that (i) were minted via Mint queries using addresses not in ADDR, or
(ii) whose mint transactions were directly placed on the ledger via Insert queries.
• vADDR→A, the total value payments received by A from addresses in ADDR. To compute vADDR→A,
the challenger C looks up all pour transactions placed on the ledger via Pour queries and sums
up the values that were transferred to addresses not in ADDR.
27That is, L(cid:48) is the longest ledger preﬁx that can be used to spend at least one of the coins spent in tx.

43

• vA→ADDR, the total value of payments sent by A to addresses in ADDR. To compute vA→ADDR,
the challenger C ﬁrst deduces the set S(cid:48) ⊆ COIN of all coins received by honest parties and then
sums up the values of coins in S(cid:48). (Note that C can compute S(cid:48) by selecting all coins in COIN
that are both tied to an address in ADDR and arose from transactions placed on the ledger by
Insert queries.)

• vBasecoin, the total value of public outputs placed by A on the ledger. To compute vBasecoin, the
challenger C looks up all pour transactions placed on the ledger by Insert and sums up the
corresponding vpub values.

At the end of the experiment, C outputs 1 if vUnspent + vBasecoin + vA→ADDR > vMint + vADDR→A; else,
C outputs 0.
Remark. There are two methods for A to spend more public-output money than he owns: (i) by
directly inserting transactions on the ledger, and (ii) by asking honest parties to create such
transactions. The ﬁrst method is accounted for in the computation of vBasecoin, while the second
method is accounted for in the computation of vA→ADDR (since A must ﬁrst pay the honest party).

D Proof of Theorem 4.1

We prove Theorem 4.1. We omit a formal proof of the completeness claim; one can verify that
the DAP scheme’s completeness follows, in a straightforward way, from the completeness of the
construction’s building blocks. Next, we argue security via three separate proofs, respectively showing
that our construction satisﬁes (i) ledger indistinguishability, (ii) transaction non-malleability, and
(iii) balance.

D.1 Proof of ledger indistinguishability
We describe a simulation (cid:97)sim in which the adversary A interacts with a challenger C, as in the
L-IND experiment. However (cid:97)sim diﬀers from the L-IND experiment in a critical way: all answers
sent to A are computed independently of the bit b, so that A’s advantage in (cid:97)sim is 0. The remainder
Π,A (λ) (i.e., A’s advantage in the L-IND experiment) is
of the proof is devoted to showing that AdvL-IND
at most negligibly diﬀerent than A’s advantage in (cid:97)sim.
The simulation. The simulation (cid:97)sim works as follows. First, after sampling b ∈ {0, 1} at random,
C samples pp ← Setup(1λ), with the following modiﬁcation: the zk-SNARK keys are generated as
(pkPOUR, vkPOUR, trap) ← Sim(1λ, CPOUR), to obtain the zero-knowledge trapdoor trap. Then, as in the
L-IND experiment, C sends pp to A, and then initializes two separate DAP oracles ODAP
and ODAP
.
Afterwards, as in L-IND, (cid:97)sim proceeds in steps and, at each step, C provides to A two ledgers
(LLeft, LRight), where LLeft := Lb is the current ledger in ODAP
and LRight := L1−b the one in ODAP
1−b ;
then A sends to C a message (Q, Q(cid:48)), which consist of two (publicly-consistent) queries of the same
type. The challenger C acts diﬀerently depending on the query type, as follows.
• Answering CreateAddress queries. In this case, Q = Q(cid:48) = CreateAddress.

1

0

b

To answer Q, C behaves as in L-IND, except for the following modiﬁcation: after obtaining
(addrpk, addrsk) ← CreateAddress(pp), C replaces apk in addrpk with a random string of the appro-
priate length; then, C stores addrsk in a table and returns addrpk to A.
Afterwards, C does the same for Q(cid:48).

44

• Answering Mint queries. In this case, Q = (Mint, v, addrpk) and Q(cid:48) = (Mint, v, addr(cid:48)

pk).

To answer Q, C behaves as in L-IND, except for the following modiﬁcation: the Mint algorithm
computes the commitment k as COMMr(τ(cid:107)ρ), for a random string τ of the appropriate length,
instead of as COMMr(apk(cid:107)ρ), where apk is the value speciﬁed in addrpk.
Afterwards, C does the same for Q(cid:48).

• Answering Pour queries. In this case, Q and Q(cid:48) both have the form (Pour, cmold

1 , cmold

2 , addrold

pk,1,

2

1

, vnew

, addrnew

pk,1, addrnew

pk,2, info, vnew

addrold
To answer Q, C modiﬁes the way some values are computed:
1. Compute rti by accumulating all of the valid coin commitments on Li.
2. Set vpub and info to the corresponding input values.
3. For each j ∈ {1, 2}:

pk,2, vnew

pub ).

(a) Sample a uniformly random snold
(b) If addrnew

j

.

a coin commitment cmnew
compute Cnew

j

pk,j is an address generated by a previous query to CreateAddress, (i) sample
on a random input, (ii) run Kenc(ppenc) → (pkenc, skenc) and

:= Eenc(pkenc, r) for a random r of suitable length.

j

(c) Otherwise, calculate (cmnew

, Cnew

) as in the Pour algorithm.28

i

i

4. Set h1 and h2 to be random strings of the appropriate length.
5. Compute all remaining values as in the Pour algorithm
6. The pour proof is computed as πPOUR := Sim(trap, x), where x := (rt, snold
Afterwards, C does the same for Q(cid:48).

1 , snold

2 , cmnew

1

, cmnew

2

, vpub, h1, h2).

• Answering Receive queries. In this case, Q = (Receive, addrpk) and Q(cid:48) = (Receive, addr(cid:48)

pk).

The answer to each query proceeds as in the L-IND experiment.

• Answering Insert queries. In this case, Q = (Insert, tx) and Q = (Insert, tx(cid:48)). The answer to

each query proceeds as in the L-IND experiment.

In each of the above cases, the response to A is computed independently of the bit b. Thus, when
A outputs a guess b(cid:48), it must be the case that Pr [ b = b(cid:48) ] = 1/2, i.e., A’s advantage in (cid:97)sim is 0.
Proof that the simulation is indistinguishable from the real experiment. We now describe
a sequence of hybrid experiments ((cid:97)real, (cid:97)1, (cid:97)2, (cid:97)3, (cid:97)sim) in each of which a challenger C conducts a
modiﬁcation of the L-IND experiment with A. We deﬁne (cid:97)real to be the original L-IND experiment,
and (cid:97)sim to be the simulation described above.
With a slight abuse of notation, given experiment (cid:97), we deﬁne Adv
to be the absolute value of the
diﬀerence between (i) the L-IND advantage of A in (cid:97) and (ii) the L-IND advantage of A in (cid:97)real.
Also, let

(cid:97)

• qCA be the total number of CreateAddress queries issued by A,
• qP be the total number of Pour queries issued by A, and
• qM be the total number of Mint queries issued by A.

Finally, deﬁne AdvEnc to be A’s advantage in Enc’s IND-CCA and IK-CCA experiments, AdvPRF to be
A’s advantage in distinguishing the pseudorandom function PRF from a random one, and AdvCOMM
to be A’s advantage against the hiding property of COMM.

We now describe each of the hybrid experiments.

28Note that by the restrictions of the experiment, the value vnew

i

is identical between QLeft and QRight.

45

• Experiment (cid:97)1. The experiment (cid:97)1 modiﬁes (cid:97)real by simulating the zk-SNARKs. More
precisely, we modify (cid:97)real so that C simulates each zk-SNARK proof, as follows. At the beginning
of the experiment, instead of invoking KeyGen(1λ, CPOUR), C invokes Sim(1λ, CPOUR) and obtains
(pkPOUR, vkPOUR, trap). At each subsequent invocation of the Pour algorithm, C computes πPOUR ←
Sim(trap, x), without using any witnesses, instead of using Prove. Since the zk-SNARK system is
perfect zero knowledge, the distribution of the simulated πPOUR is identical to that of the proofs
computed in (cid:97)real. Hence Adv

(cid:97)1 = 0.

• Experiment (cid:97)2. The experiment (cid:97)2 modiﬁes (cid:97)1 by replacing the ciphertexts in a pour
transaction by encryptions of random strings. More precisely, we modify (cid:97)1 so that, each time A
issues a Pour query where one of the output addresses (addrnew
pk,2) is in the set of addresses
previously generated by a CreateAddress query, the two ciphertexts Cnew
are generated
as follows: (i) (pknew
enc,j, r) where r
is a message sampled uniformly from the plaintext space of the encryption scheme. By Lemma D.1
(see below), |Adv
• Experiment (cid:97)3. The experiment (cid:97)3 modiﬁes (cid:97)2 by replacing all PRF-generated values with

pk,1, addrnew
enc ) ← Kenc(ppenc); (ii) for each j ∈ {1, 2}, Cnew

(cid:97)1| ≤ 4 · qP · AdvEnc.

enc , sknew
(cid:97)2 − Adv

:= Eenc(pknew

, Cnew

2

1

j

random strings. More precisely, we modify (cid:97)2 so that:

substituted with a random string of the same length;

– each time A issues a CreateAddress query, the value apk within the returned addrpk is
– each time A issues a Pour query, each of the serial numbers snold

in txPour is substituted
with a random string of the same length, and hinfo with a random string of the same length.

1 , snold
2

By Lemma D.2 (see below), |Adv

(cid:97)3 − Adv

(cid:97)2| ≤ qCA · AdvPRF.

• Experiment (cid:97)sim. The experiment (cid:97)sim is already described above. For comparison, we explain
how it diﬀers from (cid:97)3: the coin commitments are replaced with commitments to random inputs.
More precisely, we modify (cid:97)3 so that:

– each time A issues a Mint query, the coin commitment cm in txMint is substituted with a
– each time A issues a Pour query, then, for each j ∈ {1, 2}, if the output address addrnew

commitment to a random input; and

the set of addresses previously generated by an CreateAddress query, cmnew
with a commitment to a random input.
(cid:97)sim − Adv

(cid:97)3| ≤ (qM + 4 · qP) · AdvCOMM.

By Lemma D.3 (see below), |Adv

j

pk,j is in
is substituted

As argued above, the responses provided to A in (cid:97)sim are independent of the bit b, so that Adv
(cid:97)sim = 0.
Then, by summing over A’s advantages in the hybrid experiments, we can bound A’s advantage in
(cid:97)real by

AdvL-IND

Π,A (λ) ≤ 4 · qP · AdvEnc + qCA · AdvPRF + (qM + 4 · qP) · AdvCOMM ,

which is negligible in λ. This concludes the proof of ledger indistinguishability. Below, we sketch
proofs for the lemmas used above (Lemma D.1, Lemma D.2, and Lemma D.3).

Lemma D.1. Let AdvEnc be the maximum of:

• A’s advantage in the IND-CCA experiment against the encryption scheme Enc, and
• A’s advantage in the IK-CCA experiment against the encryption scheme Enc.

Then after qP Pour queries, |Adv

(cid:97)2 − Adv

(cid:97)1| ≤ 4 · qP · AdvEnc.

46

(cid:97)2 − Adv

(cid:97)1. Using A, we ﬁrst show how to construct a solver with
Proof sketch. Deﬁne (cid:15) := Adv
advantage ≥ (cid:15)
in the IK-CCA or IND-CCA experiments. We use a hybrid H, intermediate between
2·qP
(cid:97)1 and (cid:97)2; concretely, H modiﬁes (cid:97)1 so that each ciphertext (where the corresponding public key
appears in the set generated by a CreateAddress query) is replaced with the encryption of the same
plaintext, but under a new, random public key generated via the Kenc algorithm. (For comparison,
(cid:97)2 modiﬁes H so that each plaintext is replaced with a random plaintext drawn from the plaintext
space.) We now argue that A’s advantage in distinguishing H and (cid:97)1 is at most 2 · qP · AdvEnc, and
so is for distinguishing (cid:97)2 and H. Overall, we deduce that |Adv
First, we discuss H and (cid:97)1. For some j ∈ {1, . . . , qCA}, when A makes the j-th query of the
form CreateAddress, query the IK-CCA challenger to obtain two public keys (pkenc,0, pkenc,1) and
return pkenc := pkenc,0 in the response to A. At the time A issues a Pour query that results in the
i-th ciphertext Ci being encrypted under pkenc, query the IK-CCA challenger on the corresponding
plaintext m and receive C∗ = Eenc(pkenc,¯b, m) where ¯b is the bit chosen by the IK-CCA challenger.
Substitute Ci := C∗ and write the resulting txPour to the Ledger. When A outputs b(cid:48) we return
this guess as our guess in the IK-CCA experiment. We note that when ¯b = 0 then A’s view of the
interaction is distributed identically to that of (cid:97)1, and when ¯b is 1 then A’s view represents an
intermediate hybrid where one key has been substituted. By a standard hybrid argument over each
of the 2 · qP ciphertexts, we note that over the random coins of the experiment, our solver must
succeed in the IK-CCA experiment with advantage ≥ (cid:15)
. If we assume a maximum adversarial
2·qP
advantage AdvEnc against the IK-CCA experiment for the encryption scheme, then we get that

(cid:97)1| ≤ 4 · qP · AdvEnc.

(cid:97)2 − Adv

Next, we discuss (cid:97)2 and H; the argument is similar to the above one. This time, rather than
replacing the key used to encrypt, we replace the plaintext with a random message drawn from
the plaintext space; this ﬁnal distribution is the same as in (cid:97)2. We omit the formal description of
the resulting IND-CCA solver (which essentially follows the pattern above), and simply note that

(cid:12)(cid:12)AdvH − Adv
(cid:97)2(cid:12)(cid:12) ≤ 2 · qP · AdvEnc.
(cid:12)(cid:12)Adv
(cid:97)2 − AdvH(cid:12)(cid:12) ≤ 2 · qP · AdvEnc.

Lemma D.2. Let AdvPRF be A’s advantage in distinguishing the pseudorandom function PRF from
a random function. Then, after qCA CreateAddress queries, |Adv
Proof sketch. We ﬁrst describe a hybrid H, intermediate between (cid:97)2 and (cid:97)3, in which all values
computed using the ﬁrst (rather than all) oracle-generated key ask are replaced with random strings.
Then, we show that A’s advantage in distinguishing between H and (cid:97)2 is at most AdvPRF. Finally,
we extend the argument to all qCA oracle-generated keys (corresponding to what happens in (cid:97)3).
We now describe H. On receiving A’s ﬁrst CreateAddress query, replace the public address
addrpk = (apk, pkenc) with addrpk = (τ, pkenc) where τ is a random string of the appropriate length.
On each subsequent Pour query, for each i ∈ {1, 2}, if addrold

(cid:97)2| ≤ qCA · AdvPRF.

(cid:97)3 − Adv

pk,i = addrpk then:

1. in the output txPour, replace snold
2. in the output txPour, replace each of h1, h2 with a random string of appropriate length.
3. simulate the zk-SNARK proof πPOUR for the new transaction.

i with a random string of appropriate length;

Note that the above modiﬁcations do not aﬀect the computation of the zk-SNARK proof πPOUR,
because πPOUR is simulated with the help of a trapdoor.
We now argue that A’s advantage in distinguishing between H and (cid:97)2 is at most AdvPRF. Let ask
be the random, secret seed for PRF generated by the oracle in answering the ﬁrst CreateAddress
query. In (cid:97)2 (as in (cid:97)real):
(0);

• apk := PRFaddr
• for each i ∈ {1, 2}, sni := PRFsn

ask

ask

(ρ) for a random (and not previously used) ρ

47

ask
, PRFpk
ask

• for each i ∈ {1, 2}, hi := PRFpk

(i(cid:107)hSig) and, with overwhelming probability, hSig is unique.

ask

ask

ask

, PRFsn
ask

, PRFsn
ask

, PRFpk
ask

, and the calls to PRFsn
ask

Moreover, each of PRFaddr
are constructed from PRFask as speciﬁed in Section 4.1.
Note that, with overwhelming probability, no two calls to PRFask are made on the same input. First,
even identical inputs passed to PRFaddr
produce diﬀerent underlying calls to PRFask.
Second, within each construction, there is exactly one call to PRFaddr
are
each by deﬁnition unique. Finally, with overwhelming probability, the calls to PRFpk
from diﬀerent
ask
transactions each reference a distinct digest hSig, and, within a given transaction, the two calls each
begin with a distinct preﬁx.
Now let O be an oracle that implements either PRFask or a random function. We show that if
A distinguishes H from (cid:97)2 with probability (cid:15), then we can construct a distinguisher for the two
cases of O. In either case we use O to generate all values computed using PRFaddr
, PRFpk
.
ask
Clearly, when O implements PRFask, the distribution of the experiment is identical to (cid:97)2; instead,
when O implements a random function, the distribution of the experiment is identical to H. Thus,
A’s advantage is at most AdvPRF.
Finally, by a standard hybrid argument, we extend the above to all qCA oracle-generated
addresses; then, A’s diﬀerential distinguishing advantage is at most qCA · AdvPRF. Because this ﬁnal
hybrid is equal to (cid:97)3, we deduce that |Adv
Lemma D.3. Let AdvCOMM be A’s advantage against the hiding property of COMM. After qM
Mint queries and qP Pour queries, |Adv

(cid:97)3| ≤ (qM + 4 · qP) · AdvCOMM.

(cid:97)2| ≤ qCA · AdvPRF.

(cid:97)sim − Adv

(cid:97)3 − Adv

, PRFsn
ask

ask

Proof sketch. We only provide a short sketch, because the structure of the argument is similar to
the one used to prove Lemma D.2 above.
For the ﬁrst Mint or Pour query, replace the “internal” commitment k := COMMr(apk(cid:107)ρ) with
a random string of the appropriate length. Since ρ is random (and unique), then A’s advantage
in distinguishing this modiﬁed experiment from (cid:97)2 is at most AdvCOMM. Then, if we similarly
modify all qM Mint queries and all qP Pour queries, by replacing the resulting qM + 2 · qP internal
commitments with random strings, we can bound A’s advantage by (qM + 2 · qP) · AdvCOMM.
Next, in a similar vein, if replace the coin commitment in the ﬁrst Pour with a commitment to
a random value, then A’s advantage in distinguishing this modiﬁed experiment from the above one
is at most AdvCOMM. Then, if we similarly modify all qP Pour queries, by replacing the resulting
2 · qP coin commitments with random strings, we obtain the experiment (cid:97)sim, and deduce that
|Adv

(cid:97)3| ≤ (qM + 4 · qP) · AdvCOMM.

(cid:97)sim − Adv

D.2 Proof of transaction non-malleability
Letting T be the set of pour transactions generated by ODAP in response to Pour queries, recall
that A wins the TR-NM experiment whenever it outputs tx∗ such that there exists tx(cid:48) ∈ T such that:
(i) tx∗ (cid:54)= tx(cid:48); (ii) VerifyTransaction(pp, tx∗, L(cid:48)) = 1, where L(cid:48) is the portion of the ledger preceding
tx(cid:48); and (iii) a serial number revealed in tx∗ is also revealed in tx(cid:48). Being a pour transaction, tx∗
, vpub, info,∗), where ∗ := (pksig, h1, h2, πPOUR, C1, C2, σ); set
1 , snold
has the form (rt, snold
hSig := CRH(pksig). Let pk(cid:48)
Π,A (λ), and let QCA = {ask,1, . . . , ask,qCA} be the set of internal address keys
Deﬁne (cid:15) := AdvTR-NM
created by C in response to A’s CreateAddress queries. Let QP = (pksig,1, . . . , pksig,qP
) be the set
of signature public keys created by C in response to A’s Pour queries. We decompose the event in
which A wins into the following four disjoint events.
• Eventsig: A wins, and there is pk(cid:48)(cid:48)

sig be the corresponding public key in tx(cid:48) and set h(cid:48)

sig ∈ QP such that pksig = pk(cid:48)(cid:48)
sig.

Sig := CRH(pk(cid:48)

2 , cmnew

, cmnew

sig).

1

2

48

sig).

• Eventcol: A wins, the above event does not occur, and there is pk(cid:48)(cid:48)
• Eventmac: A wins, the above two events do not occur, and hi = PRFpk
• Eventkey: A wins, the above three events do not occur, and hi (cid:54)= PRFpk

sig ∈ QP such that hSig =
a (i(cid:107)hSig) for some i ∈ {1, 2}
a (i(cid:107)hSig) for all i ∈ {1, 2}

CRH(pk(cid:48)(cid:48)
and a ∈ QCA.
and a ∈ QCA.

Clearly, (cid:15) = Pr [ Eventsig ] + Pr [ Eventcol ] + Pr [ Eventkey ] + Pr [ Eventmac ]. Hence, to show
that (cid:15) is negligible in λ, it suﬃces to argue that each of these probabilities is negligible in λ.
Bounding the probability of Eventsig. Deﬁne (cid:15)1 := Pr [ Eventsig ]. Let σ be the signature
in tx∗, and σ(cid:48)(cid:48) be the signature in the ﬁrst pour transaction tx(cid:48)(cid:48) ∈ T that contains pk(cid:48)(cid:48)
sig. When
Eventsig occurs, since pksig = pk(cid:48)(cid:48)
sig, the two signatures are with respect to the same public key.
Moreover, since tx∗ is valid, Vsig(pksig, m, σ) = 1 where m is everything in tx∗ but for σ. Let m(cid:48)(cid:48)
consist of all elements in tx(cid:48)(cid:48) but for σ(cid:48)(cid:48). Observe that whenever tx∗ (cid:54)= tx(cid:48)(cid:48) we also have (m, σ)
(cid:54)= (m(cid:48)(cid:48), σ(cid:48)(cid:48)). We use this fact below to show that A forges a signature with non-negligible probability.
First, we argue that, conditioned on Eventsig, tx∗ (cid:54)= tx(cid:48)(cid:48) with overwhelming probability; we do
so by way of contradiction. First, since A wins, by deﬁnition there is tx(cid:48) ∈ T such that tx∗ (cid:54)= tx(cid:48)
and yet each of tx∗ and tx(cid:48) share one serial number. Therefore: (i) tx∗ (cid:54)= tx(cid:48); and (ii) if tx∗ = tx(cid:48)(cid:48)
then tx(cid:48)(cid:48) and tx(cid:48) also share a serial number. However the probability that tx(cid:48) and tx(cid:48)(cid:48) share a serial
number is bounded by the probability ˜p that T contains two transactions that share the same serial
number. Because each serial number is computed as PRFsn
(ρ), where ρ is random, ˜p is negligible.
ask
We conclude that tx∗ (cid:54)= tx(cid:48)(cid:48) with all but negligible probability.
Next, we describe an algorithm B, which uses A as a subroutine, that wins the SUF-1CMA game
against Sig with probability (cid:15)1/qP. After receiving a veriﬁcation key pk(cid:48)(cid:48)
sig from the SUF-1CMA
challenger, the algorithm B performs the following steps.

1. B selects a random index j ← {1, . . . , qP}.
2. B conducts the TR-NM experiment with A, except that, when A issues the j-th Pour query,
B executes Pour as usual, but modiﬁes the resulting pour transaction tx(cid:48)(cid:48) as follows: (i) it
substitutes pk(cid:48)(cid:48)
sig for the signature public key in tx(cid:48)(cid:48); (ii) it queries the SUF-1CMA challenger to
obtain σ(cid:48)(cid:48) on the appropriate message m(cid:48)(cid:48); and (iii) it substitutes σ(cid:48)(cid:48) for the signature in tx(cid:48)(cid:48).

3. When A outputs tx∗, B looks into tx∗ to obtain pksig, m, and σ.
4. If pksig (cid:54)= pk(cid:48)(cid:48)

sig then B aborts; otherwise B outputs (m, σ) as a forgery for Sig.

Note that tx(cid:48)(cid:48) has the same distribution has an “untampered” pour transaction; thus, all transactions
returned to A are distributed as in the TR-NM experiment. Since the index j is selected at random,
B succeeds in the experiment with probability at least (cid:15)1/qP. Because Sig is SUF-1CMA, (cid:15)1 must
be negligible in λ.
Bounding the probability of Eventcol. Deﬁne (cid:15)2 := Pr [ Eventcol ]. When Eventcol occurs,
A receives a transaction tx(cid:48) containing a public key pk(cid:48)(cid:48)
sig, and subsequently outputs a transaction
tx∗ containing a public key pksig such that (i) pksig (cid:54)= pk(cid:48)(cid:48)
sig). In
particular, A ﬁnds collisions for CRH with probability (cid:15)2. Because CRH is collision resistant, (cid:15)2
must be negligible in λ.
Bounding the probability of Eventmac. Deﬁne (cid:15)3 := Pr [ Eventmac ]. We ﬁrst deﬁne an exper-
iment (cid:97)1, which modiﬁes the TR-NM experiment as follows. When C samples pp ← Setup(1λ), the
sub-call to (pkPOUR, vkPOUR) ← KeyGen(1λ, CPOUR) is replaced by (pkPOUR, vkPOUR, trap) ← Sim(1λ, CPOUR),
so to obtain the zero-knowledge trapdoor trap. Afterwards, each time A issues a Pour query, C
replaces the zk-SNARK proof in the resulting pour transaction with a simulated proof, obtained by
running Sim(trap, x) for an appropriate input x. Because the zk-SNARK is perfect zero knowledge,
Pr [ Eventmac ] = (cid:15)3 in the (cid:97)1 experiment as well.

sig, but (ii) CRH(pksig) = CRH(pk(cid:48)

49

Assume by way of contradiction that (cid:15)3 is non-negligible. We now show how to construct an
attacker B, which uses A as a subroutine, that distinguishes PRF from a random function RAND
with non-negligible probability. The algorithm B, which has access either to O = PRF or O = RAND,
“interfaces” between A and C in the experiment (cid:97)1 above, as follows.

1. First, B selects a random index j ← {1, . . . , qCA}, which identiﬁes ask,j ∈ QCA.
2. Next, B uses the oracle O instead of PRFask,j , i.e., anytime a value needs to be computed
depending on PRFask,j (z), for some z, O(z) is used instead. (For instance, the public address
key apk,j is one such value.)
3. Finally, after A outputs tx∗:
(a) if O has been previously evaluated the expression “PRFpk
(b) otherwise, B evaluates the expression “PRFpk

(i(cid:107)hSig)” using O, B aborts
(i(cid:107)hSig)” by using O; if the result equals

ask,j

and outputs 1;
hi, B outputs 1, else it outputs 0.

Conducting the above strategy does not require knowledge of ask,j because, having the simulation
trapdoor, B does not need witnesses to generate (valid) zk-SNARK proofs.

We now argue that(cid:12)(cid:12)Pr(cid:2)BPRF(1λ) = 1(cid:3) − Pr(cid:2)BRAND(1λ) = 1(cid:3)(cid:12)(cid:12) is non-negligible.

ask,j

• Case 1: O = RAND. Observe that:

(cid:104)BRAND(1λ) = 1 | BRAND(1λ) does not abort
(cid:105)
(cid:105)(cid:17) · 2−ω + Pr
(cid:105)

(cid:104)BRAND(1λ) aborts

1 − Pr

(cid:16)

=

Pr

(cid:104)BRAND(1λ) = 1

Pr

where ω is the output length of PRF. Hence:

= 2−ω .

(cid:104)BRAND(1λ) aborts

(cid:105)

.

• Case 2: O = PRF. In this case the distribution of the simulation is identical to that of (cid:97)1, and B
a (i(cid:107)hSig)
has set ask,j equal to the seed used by O. Recall that, when Eventmac holds, hi = PRFpk
for some a ∈ QCA. Since A’s view of the experiment is independent of j, the probability that
(i(cid:107)hSig) is at least (cid:15)3/qCA.
a = ask,j is at least 1/qCA, and the probability that hi = PRFpk
ask,j
Hence:

(cid:104)BPRF(1λ) = 1 | BPRF(1λ) does not abort
(cid:105)

(cid:104)BPRF(1λ) aborts

1 − Pr

(cid:105)(cid:17) · (cid:15)3/qCA + Pr

(cid:16)

(cid:105)

=

= (cid:15)3/qCA .

(cid:104)BPRF(1λ) aborts

(cid:105)

.

Thus:

Pr

(cid:104)BPRF(1λ) = 1

Pr

Clearly, 2−ω is negligible; moreover, if (cid:15)3 is non-negligible, then so is |(cid:15)3/qCA|. Thus, to show

that(cid:12)(cid:12)Pr(cid:2)BPRF(1λ) = 1(cid:3) − Pr(cid:2)BRAND(1λ) = 1(cid:3)(cid:12)(cid:12) is non-negligible, it suﬃces to show that each of
Pr(cid:2)BRAND(1λ) aborts(cid:3) and Pr(cid:2)BPRF(1λ) aborts(cid:3) is negligible.

To do so, recall that B aborts if and only if it has previously evaluated the expression
(i(cid:107)hSig)” using O prior to receiving A’s output. First note that B’s only calls to O occur
“PRFpk
ask,j
when it evaluates the functions PRFaddr, PRFsn and PRFpk. Moreover, due to the construction
(i(cid:107)hSig) using any calls to
of these functions it is not possible to evaluate the expression PRFpk
ask,j
PRFaddr or PRFsn. Thus B aborts if and only if it has previously queried PRFpk on the expression
(i(cid:107)hSig). However it is easy to see that this cannot happen under the conditions of Eventmac,
PRFpk
ask,j
since such a query would imply the condition Eventsig or Eventcol, each of which is excluded by
Eventmac. Hence the probability of either condition occurring is 0.

50

Bounding the probability of Eventkey. Deﬁne (cid:15)4 := Pr [ Eventkey ], and let E be the zk-SNARK
extractor for A. Assume by way of contradiction that (cid:15)4 is non-negligible. We construct an algorithm
B that ﬁnds collisions for PRFsn with non-negligible probability (contradicting the fact that PRFsn
is collision resistant). The algorithm B works as follows.

1. Run A (simulating its interaction with the challenger C) to obtain tx∗.
2. Run E(pkPOUR, vkPOUR) to obtain a witness a for the zk-SNARK proof πPOUR in tx∗.
3. If a is not a valid witness for the instance x := (rt, snold

, cmnew

1 , snold

2 , cmnew

1

2

, vpub, hSig, h1, h2),

abort and output 0.

4. Parse a as (path1, path2, cold
1 , cold
5. For each i ∈ {1, 2}, parse cold
6. For each i ∈ {1, 2}, parse addrold

2 , addrold
as (addrold
sk,i as (aold
(Note that, since a is a valid witness, snold

i

i

sk,1, addrold
sk,2, cnew
1
, ρold
, rold
pk,i, vold
i
sk,i, skold
enc,i).
i = PRFsn
aold
sk,i

i

7. For each i ∈ {1, 2}:

2

, cnew
, sold

).
, cmold

i

i ).

i ) for all i ∈ {1, 2}.)
(ρold

(a) Look for a pour transaction tx ∈ T that contains snold
(b) If one tx is found, let ask and ρ be the seed and input used to compute snold

i ), (ask, ρ)(cid:1) as a collision for PRFsn.

sk,i (cid:54)= ask, output(cid:0)(aold

i = PRFsn
ask

(ρ). If aold

sk,i, ρold

snold

.

i

i

in tx; thus,

Note that, whenever Eventkey holds:

• the proof πPOUR is valid and, with all but negligible probability, the witness a is valid;
• the serial number snold
• whenever a is valid, it holds that h1 = PRFpk

2 appears in some previous pour transaction in T ;

1 or snold

(hSig) and h2 = PRFpk
aold
sk,2

aold
sk,1

(hSig), so that it cannot

be that aold

Overall, we conclude that B ﬁnds a collision for PRFsn with probability (cid:15)4 − negl(λ).

sk,2 = ask (as this contradicts the conditions of the event Eventkey).

sk,1 = aold

D.3 Proof of balance

Π,A(λ); our goal is to show that (cid:15) is negligible in λ. Recall that ADDR is the set of

Deﬁne (cid:15) := AdvBAL
addresses returned by A’s CreateAddress queries.
Augmenting the ledger with witnesses. We modify the BAL experiment in a way that does
not aﬀect A’s view: the challenger C computes, for each pour transaction txPour on the ledger L
(maintained by the oracle ODAP), a witness a = (path1, path2, cold
1 , cold
, cnew
)
for the zk-SNARK instance x = (rt, snold
, vpub, hSig, h1, h2) corresponding to
txPour.29 In this way, C obtains an augmented ledger (L, (cid:126)a), where ai is a witness for the zk-SNARK
instance xi of the i-th pour transaction in L. Note that we can parse (L, (cid:126)a) as a list of matched
pairs (txPour, a) where txPour is a pour transaction in L and a is its corresponding witness.

sk,1, addrold

2 , addrold

2 , cmnew

sk,2, cnew

1 , snold

, cmnew

1

1

2

2

The discussion below is relative to the above modiﬁcation of the BAL experiment.

Balanced ledgers. We say that an augmented ledger (L, (cid:126)a) is balanced if the following holds.

I. Each (txPour, a) in (L, (cid:126)a) contains openings (i.e., decommitments) of two distinct coin com-
is the output coin commitment of a pour or mint

mitments cmold
transaction that precedes txPour on L.

1 and cmold

2 ; also, each cmold

i

II. No two (txPour, a) and (a(cid:48), tx(cid:48)
Pour) in (L, (cid:126)a) contain openings of the same coin commitment.
29 Concretely, for pour transactions in L not inserted by A, C simply retains the witness a internally used by ODAP
to generate the transaction. As for the (valid) pour transactions inserted by A, C uses the zk-SNARK multi-instance
knowledge extractor corresponding to A; see Section 2.1. (If knowledge extraction fails, C aborts and outputs 1.
However, this only happens with negligible probability.)

51

vnew
1

III. Each (txPour, a) in (L, (cid:126)a) contains openings of cmold
(respectively), with the condition that vold

2 + vpub.
IV. For each (txPour, a) in (L, (cid:126)a) and for each i ∈ {1, 2}, the following conditions hold:

, cmnew
1
1 + vnew

2 , cmnew
2 = vnew

1 , cmold
1 + vold

, vnew

2

2

to values vold

1 , vold
2 ,

(a) If cmold

txMint is equal to vold

is also the output of a mint transaction txMint on L, then the public value v in
Pour on L, then its witness a(cid:48) contains
is also the output of a pour transaction tx(cid:48)

.
to a value v(cid:48) that is equal to vold

.

i

an opening of cmold

i

i

i

i

(b) If cmold

V. For each (txPour, a) in (L, (cid:126)a), where txPour was inserted by A, it holds that, for each i ∈ {1, 2},
is the output of an earlier mint or pour transaction tx(cid:48), then the public address of the

if cmold
i-th output of tx(cid:48) is not contained in ADDR.

i

Intuitively, the above conditions ensure that, in L, A did not spend money that was not previously
minted, or paid to an address under A’s control. Concretely, one can prove by induction that if
(L, (cid:126)a) is balanced then vUnspent + vBasecoin + vA→ADDR > vMint + vADDR→A.

In light of the above, it suﬃces to argue that the augmented ledger induced by the (modiﬁed) BAL
experiment is balanced with all but negligible probability. Suppose, by way of contradiction, that is
is not the case: A induces, with non-negligible probability, an augmented ledger (L, (cid:126)a) that is not
balanced. We distinguish between ﬁve cases, corresponding to which one of the above conditions
does not hold with non-negligible probability. In each case, we show how to reach a contradiction,
concluding the proof.
A violates Condition I. Suppose that Pr [A wins but violates Condition I ] is non-negligible.
By construction of ODAP, every (txPour, a) in (L, (cid:126)a) for which txPour was not inserted by A satisﬁes
Condition I; thus, the violation can only originate from a pair (txPour, a) in (L, (cid:126)a) for which txPour
was inserted by A and such that: (i) cmold
i has no
corresponding output coin commitment in any pour or mint transaction that precedes txPour on L.
• The two serial numbers snold

2 ; or (ii) there is i ∈ {1, 2} such that cmold

Observe that the validity of txPour implies that:

1 = cmold

1 and snold
i ), this also implies that (aold

2 are distinct. Moreover, recalling that each snold
sk,1, ρold

1 ) (cid:54)= (aold

sk,2, ρold

• The witness a contains two valid authentication paths path1, path2 for a Merkle tree constructed

PRFsn
aold
sk,i

equals

(ρold

2 ).

i

using only coin commitments of transactions preceding txPour in L.

In either (i) or (ii), we reach a contradiction. Indeed:

(cid:54)= snold

2

1

(i) If cmold

1 = cmold

2 , then the fact that snold
1

(the ﬁrst opening contains (aold

distinct openings of cmold
contains (aold

implies that the witness a contains two
1 ), while the second opening
2 )). This violates the binding property of the commitment scheme COMM.
i does not previously appear in L, then pathi is an invalid
authentication path, and thus yields a collision in the function CRH. This violates the collision
resistance of CRH.

(ii) If there is i ∈ {1, 2} such that cmold

sk,2, ρold

sk,1, ρold

A violates Condition II. Suppose that Pr [A wins but violates Condition II ] is non-negligible.
Observe that, when Condition II is violated, L contains two pour transactions txPour, tx(cid:48)
Pour spending
the same coin commitment cm, and revealing two serial numbers sn and sn(cid:48). Since txPour, tx(cid:48)
Pour are
valid, it must be the case that sn (cid:54)= sn(cid:48). However (as argued already above), if both transactions
spend cm but produce diﬀerent serial numbers, then the corresponding witnesses a, a(cid:48) contain
diﬀerent openings of cm. This contradicts the binding property of the commitment scheme COMM.
A violates Condition III. Suppose that Pr [A wins but violates Condition III ] is non-negligible.
In this case, the contradiction is immediate: whenever Condition III is violated, the equation

52

2 = vnew

1 + vnew

vold
1 + vold
2 + vpub does not hold, and thus, by construction of the statement POUR, the
soundness of the zk-SNARK is violated as well.
A violates Condition IV. Suppose that Pr [A wins but violates Condition IV ] is non-negligible.
Observe that, when Condition IV is violated, L contains:
• a pour transaction txPour in which a coin commitment cmold is opened to a value vold; and also
• a (mint or pour) transaction tx(cid:48) that opens cmold to a value v(cid:48) diﬀerent from vold.
This contradicts the binding property of the commitment scheme COMM.
A violates Condition V. Suppose that Pr [A wins but violates Condition V ] is non-negligible.
Observe that, when Condition V is violated, L contains an inserted pour transaction txPour that
spends the output of a previous transaction tx(cid:48) whose public address addrpk = (apk, pkenc) lies in
ADDR; moreover, the witness associated to tx(cid:48) contains ask such that apk = PRFaddr
(0). We omit
the full argument, but one can verify that, in this case, we can construct a new adversary B that
uses A to distinguish, with non-negligible probability, PRF from a random function.

ask

53

References

[BB04]

Dan Boneh and Xavier Boyen. Secure identity based encryption without random oracles. In Proceedings
of the 24th Annual International Cryptology Conference, CRYPTO ’04, pages 443–459, 2004.

[BBDP01] Mihir Bellare, Alexandra Boldyreva, Anand Desai, and David Pointcheval. Key-privacy in public-
key encryption. In Proceedings of the 7th International Conference on the Theory and Application of
Cryptology and Information Security, ASIACRYPT ’01, pages 566–582, 2001.

[BBSU12]

Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. Bitter to better - how to make Bitcoin a
better currency. In Proceedings of the 16th International Conference on Financial Cryptography and Data
Security, FC ’12, pages 399–414, 2012.

[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to
succinct non-interactive arguments of knowledge, and back again. In Proceedings of the 3rd Innovations
in Theoretical Computer Science Conference, ITCS ’12, pages 326–349, 2012.

[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping
for SNARKs and proof-carrying data. In Proceedings of the 45th ACM Symposium on the Theory of
Computing, STOC ’13, pages 111–120, 2013.

[BCG+13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. SNARKs for
C: verifying program executions succinctly and in zero knowledge. In Proceedings of the 33rd Annual
International Cryptology Conference, CRYPTO ’13, pages 90–108, 2013.

[BCGT13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to
delegatable succinct constraint satisfaction problems. In Proceedings of the 4th Innovations in Theoretical
Computer Science Conference, ITCS ’13, pages 401–414, 2013.

[BCGT13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. On the concrete eﬃciency
of probabilistically-checkable proofs. In Proceedings of the 45th ACM Symposium on the Theory of
Computing, STOC ’13, pages 585–594, 2013.

[BCI+13]

Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-
interactive arguments via linear interactive proofs. In Proceedings of the 10th Theory of Cryptography
Conference, TCC ’13, pages 315–333, 2013.

[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero
knowledge for a von Neumann architecture. In Proceedings of the 23rd USENIX Security Symposium,
Security ’14, pages ???–???, 2014. Available at http://eprint.iacr.org/2013/879.

[Bel06]

[Ben13]

[BFLS91]

Mihir Bellare. New proofs for NMAC and HMAC: security without collision-resistance. In Proceedings of
the 26th Annual International Conference on Advances in Cryptology, CRYPTO ’06, pages 602–619, 2006.

Eli Ben-Sasson. Universal and aﬀordable computational integrity, May 2013. Bitcoin 2013: The Future
of Payments. URL: http://www.youtube.com/watch?v=YRcPReUpkcU&feature=youtu.be&t=26m6s.

L´aszl´o Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polyloga-
rithmic time. In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, STOC ’91,
pages 21–32, 1991.

[BGH+05] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil Vadhan. Short PCPs
veriﬁable in polylogarithmic time. In Proceedings of the 20th Annual IEEE Conference on Computational
Complexity, CCC ’05, pages 120–134, 2005.

[Cer00]

[Cha82]

[CHL05]

[CL01]

Certicom Research. SEC 1: Elliptic curve cryptography, 2000. URL: http://www.secg.org/collateral/
sec1_final.pdf.

David Chaum. Blind signatures for untraceable payments. In Proceedings of the 2nd Annual International
Cryptology Conference, CRYPTO ’82, pages 199–203, 1982.

Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In Proceedings of the 24th
Annual International Conference on Theory and Applications of Cryptographic Techniques, EUROCRYPT
’05, pages 302–321, 2005.

Jan Camenisch and Anna Lysyanskaya. An eﬃcient system for non-transferable anonymous credentials
with optional anonymity revocation. In Proceedings of the 20th Annual International Conference on
Theory and Application of Cryptographic Techniques, EUROCRYPT ’01, pages 93–118, 2001.

[DDM03]

George Danezis, Roger Dingledine, and Nick Mathewson. Mixminion: Design of a type III anonymous
remailer protocol. In Proceedings of the 2003 IEEE Symposium on Security and Privacy, SP ’03, pages
2–15, 2003.

54

[DFKP13] George Danezis, Cedric Fournet, Markulf Kohlweiss, and Bryan Parno. Pinocchio Coin: building Zerocoin
from a succinct pairing-based proof system. In Proceedings of the 2013 Workshop on Language Support
for Privacy Enhancing Technologies, PETShop ’13, 2013. URL: http://www0.cs.ucl.ac.uk/staff/G.
Danezis/papers/DanezisFournetKohlweissParno13.pdf.

[DMS04]

Roger Dingledine, Nick Mathewson, and Paul Syverson. Tor: the second-generation onion router. In
Proceedings of the 13th USENIX Security Symposium, Security ’04, pages 21–21, 2004.

[DW13]

[ES13]

[Gen04]

Christian Decker and Roger Wattenhofer. Information propagation in the Bitcoin network. In Proceedings
of the 13th IEEE International Conference on Peer-to-Peer Computing, P2P ’13, pages 1–10, 2013.

Ittay Eyal and Emin G¨un Sirer. Majority is not enough: Bitcoin mining is vulnerable, 2013.

Rosario Gennaro. Multi-trapdoor commitments and their applications to proofs of knowledge secure
under concurrent man-in-the-middle attacks. In Proceedings of the 24th Annual International Cryptology
Conference, CRYPTO ’04, pages 220–236, 2004.

[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and
succinct NIZKs without PCPs. In Proceedings of the 32nd Annual International Conference on Theory
and Application of Cryptographic Techniques, EUROCRYPT ’13, pages 626–645, 2013.

[GMR89]

[GOS06a]

[GOS06b]

[Gro10]

[GW11]

[KL07]

[Lee13]

[Lip12]

[Lip13]

Shaﬁ Goldwasser, Silvio Micali, and Charles Rackoﬀ. The knowledge complexity of interactive proof
systems. SIAM Journal on Computing, 18(1):186–208, 1989. Preliminary version appeared in STOC ’85.

Jens Groth, Rafail Ostrovsky, and Amit Sahai. Non-interactive Zaps and new techniques for NIZK. In
Proceedings of the 26th Annual International Conference on Advances in Cryptology, CRYPTO ’06, pages
97–111, 2006.

Jens Groth, Rafail Ostrovsky, and Amit Sahai. Perfect non-interactive zero knowledge for NP. In
Proceedings of the 25th Annual International Conference on Advances in Cryptology, EUROCRYPT ’06,
pages 339–358, 2006.

Jens Groth. Short pairing-based non-interactive zero-knowledge arguments.
In Proceedings of the
16th International Conference on the Theory and Application of Cryptology and Information Security,
ASIACRYPT ’10, pages 321–340, 2010.

Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsiﬁable
assumptions. In Proceedings of the 43rd Annual ACM Symposium on Theory of Computing, STOC ’11,
pages 99–108, 2011.

Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptography. Chapman & Hall/CRC, 2007.

Timothy B. Lee. Bitcoin needs to scale by a factor of 1000 to compete with Visa. here’s how to do it.
The Washington Post (http://www.washingtonpost.com), November 2013.

Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge argu-
ments. In Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography, TCC ’12,
pages 169–189, 2012.

Helger Lipmaa. Succinct non-interactive zero knowledge arguments from span programs and linear
error-correcting codes. In Proceedings of the 19th International Conference on the Theory and Application
of Cryptology and Information Security, ASIACRYPT ’13, pages 41–60, 2013.

[Max13]

Greg Maxwell. CoinJoin: Bitcoin privacy for the real world, August 2013. Bitcoin Forum. URL:
https://bitcointalk.org/index.php?topic=279249.0.

[MGGR13]

Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous distributed
e-cash from bitcoin. In Proceedings of the 2013 IEEE Symposium on Security and Privacy, SP ’13, pages
397–411, 2013.

[Mic00]

[MPJ+13]

[Nak09]

[Nat12]

Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000.
Preliminary version appeared in FOCS ’94.

Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon McCoy, Geoﬀrey M.
Voelker, and Stefan Savage. A ﬁstful of Bitcoins: Characterizing payments among men with no names. In
Proceedings of the 2013 Conference on Internet Measurement Conference, IMC ’13, pages 127–140, 2013.

Satoshi Nakamoto. Bitcoin: a peer-to-peer electronic cash system, 2009. URL: http://www.bitcoin.
org/bitcoin.pdf.

National Institute of Standards and Technology. FIPS PUB 180-4: Secure Hash Standard. http:
//csrc.nist.gov/publications/PubsFIPS.html, 2012.

55

[PGHR13] Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: nearly practical veriﬁable
computation. In Proceedings of the 34th IEEE Symposium on Security and Privacy, Oakland ’13, pages
238–252, 2013.

[Pol13]

[RM11]

[RS12]

[ST99]

[Val08]

[Wui14]

PolarSSL. PolarSSL. http://polarssl.org, Oct 2013.

Fergal Reid and Harrigan Martin. An analysis of anonymity in the Bitcoin system. In Proceedings of
the 3rd IEEE International Conference on Privacy, Security, Risk and Trust and on Social Computing,
SocialCom/PASSAT ’11, pages 1318–1326, 2011.

Dorit Ron and Adi Shamir. Quantitative analysis of the full Bitcoin transaction graph. Cryptology
ePrint Archive, Report 2012/584, 2012.

Tomas Sander and Amnon Ta-Shma. Auditable, anonymous electronic cash. In Proceedings of the 19th
Annual International Cryptology Conference on Advances in Cryptology, CRYPTO ’99, pages 555–572,
1999.

Paul Valiant. Incrementally veriﬁable computation or proofs of knowledge imply time/space eﬃciency.
In Proceedings of the 5th Theory of Cryptography Conference, TCC ’08, pages 1–18, 2008.

Pieter Wuille. Proposed BIP for dealing with malleability. Available at https://gist.github.com/
sipa/8907691, 2014.

56

