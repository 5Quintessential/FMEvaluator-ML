CryptoNote v 2.0

Nicolas van Saberhagen

October 17, 2013

1

Introduction

“Bitcoin” [1] has been a successful implementation of the concept of p2p electronic cash. Both
professionals and the general public have come to appreciate the convenient combination of
public transactions and proof-of-work as a trust model. Today, the user base of electronic cash
is growing at a steady pace; customers are attracted to low fees and the anonymity provided
by electronic cash and merchants value its predicted and decentralized emission. Bitcoin has
eﬀectively proved that electronic cash can be as simple as paper money and as convenient as
credit cards.

Unfortunately, Bitcoin suﬀers from several deﬁciencies. For example, the system’s distributed
nature is inﬂexible, preventing the implementation of new features until almost all of the net-
work users update their clients. Some critical ﬂaws that cannot be ﬁxed rapidly deter Bitcoin’s
widespread propagation. In such inﬂexible models, it is more eﬃcient to roll-out a new project
rather than perpetually ﬁx the original project.

In this paper, we study and propose solutions to the main deﬁciencies of Bitcoin. We believe
that a system taking into account the solutions we propose will lead to a healthy competition
among diﬀerent electronic cash systems. We also propose our own electronic cash, “CryptoNote”,
a name emphasizing the next breakthrough in electronic cash.

2 Bitcoin drawbacks and some possible solutions

2.1 Traceability of transactions

Privacy and anonymity are the most important aspects of electronic cash. Peer-to-peer payments
seek to be concealed from third party’s view, a distinct diﬀerence when compared with traditional
banking. In particular, T. Okamoto and K. Ohta described six criteria of ideal electronic cash,
which included “privacy: relationship between the user and his purchases must be untraceable
by anyone” [30]. From their description, we derived two properties which a fully anonymous
electronic cash model must satisfy in order to comply with the requirements outlined by Okamoto
and Ohta:

Untraceability: for each incoming transaction all possible senders are equiprobable.

Unlinkability: for any two outgoing transactions it is impossible to prove they were sent to

the same person.

Unfortunately, Bitcoin does not satisfy the untraceability requirement. Since all the trans-
actions that take place between the network’s participants are public, any transaction can be

1

unambiguously traced to a unique origin and ﬁnal recipient. Even if two participants exchange
funds in an indirect way, a properly engineered path-ﬁnding method will reveal the origin and
ﬁnal recipient.

It is also suspected that Bitcoin does not satisfy the second property. Some researchers
stated ([33, 35, 29, 31]) that a careful blockchain analysis may reveal a connection between
the users of the Bitcoin network and their transactions. Although a number of methods are
disputed [25], it is suspected that a lot of hidden personal information can be extracted from the
public database.

Bitcoin’s failure to satisfy the two properties outlined above leads us to conclude that it is
not an anonymous but a pseudo-anonymous electronic cash system. Users were quick to develop
solutions to circumvent this shortcoming. Two direct solutions were “laundering services” [2] and
the development of distributed methods [3, 4]. Both solutions are based on the idea of mixing
several public transactions and sending them through some intermediary address; which in turn
suﬀers the drawback of requiring a trusted third party.

Recently, a more creative scheme was proposed by I. Miers et al. [28]: “Zerocoin”. Zerocoin
utilizes a cryptographic one-way accumulators and zero-knoweldge proofs which permit users to
“convert” bitcoins to zerocoins and spend them using anonymous proof of ownership instead of
explicit public-key based digital signatures. However, such knowledge proofs have a constant
but inconvenient size - about 30kb (based on today’s Bitcoin limits), which makes the proposal
impractical. Authors admit that the protocol is unlikely to ever be accepted by the majority of
Bitcoin users [5].

2.2 The proof-of-work function

Bitcoin creator Satoshi Nakamoto described the majority decision making algorithm as “one-
CPU-one-vote” and used a CPU-bound pricing function (double SHA-256) for his proof-of-work
scheme. Since users vote for the single history of transactions order [1], the reasonableness and
consistency of this process are critical conditions for the whole system.

The security of this model suﬀers from two drawbacks. First, it requires 51% of the network’s
mining power to be under the control of honest users. Secondly, the system’s progress (bug ﬁxes,
security ﬁxes, etc...) require the overwhelming majority of users to support and agree to the
changes (this occurs when the users update their wallet software) [6].Finally this same voting
mechanism is also used for collective polls about implementation of some features [7].

This permits us to conjecture the properties that must be satisﬁed by the proof-of-work
pricing function. Such function must not enable a network participant to have a signiﬁcant
advantage over another participant; it requires a parity between common hardware and high
cost of custom devices. From recent examples [8], we can see that the SHA-256 function used
in the Bitcoin architecture does not posses this property as mining becomes more eﬃcient on
GPUs and ASIC devices when compared to high-end CPUs.

Therefore, Bitcoin creates favourable conditions for a large gap between the voting power of
participants as it violates the “one-CPU-one-vote” principle since GPU and ASIC owners posses
a much larger voting power when compared with CPU owners. It is a classical example of the
Pareto principle where 20% of a system’s participants control more than 80% of the votes.

One could argue that such inequality is not relevant to the network’s security since it is not
the small number of participants controlling the majority of the votes but the honesty of these
participants that matters. However, such argument is somewhat ﬂawed since it is rather the
possibility of cheap specialized hardware appearing rather than the participants’ honesty which
poses a threat. To demonstrate this, let us take the following example. Suppose a malevolent
individual gains signiﬁcant mining power by creating his own mining farm through the cheap

2

hardware described previously. Suppose that the global hashrate decreases signiﬁcantly, even for
a moment, he can now use his mining power to fork the chain and double-spend. As we shall see
later in this article, it is not unlikely for the previously described event to take place.

2.3 Irregular emission

Bitcoin has a predetermined emission rate: each solved block produces a ﬁxed amount of coins.
Approximately every four years this reward is halved. The original intention was to create a
limited smooth emission with exponential decay, but in fact we have a piecewise linear emission
function whose breakpoints may cause problems to the Bitcoin infrastructure.

When the breakpoint occurs, miners start to receive only half of the value of their previous
reward. The absolute diﬀerence between 12.5 and 6.25 BTC (projected for the year 2020) may
seem tolerable. However, when examining the 50 to 25 BTC drop that took place on November
28 2012, felt inappropriate for a signiﬁcant number of members of the mining community. Figure
1 shows a dramatic decrease in the network’s hashrate in the end of November, exactly when the
halving took place. This event could have been the perfect moment for the malevolent individual
described in the proof-of-work function section to carry-out a double spending attack [36].

Fig. 1. Bitcoin hashrate chart
(source: http://bitcoin.sipa.be)

2.4 Hardcoded constants

Bitcoin has many hard-coded limits, where some are natural elements of the original design (e.g.
block frequency, maximum amount of money supply, number of conﬁrmations) whereas other
seem to be artiﬁcial constraints. It is not so much the limits, as the inability of quickly changing

3

them if necessary that causes the main drawbacks. Unfortunately, it is hard to predict when the
constants may need to be changed and replacing them may lead to terrible consequences.

A good example of a hardcoded limit change leading to disastrous consequences is the block
size limit set to 250kb1. This limit was suﬃcient to hold about 10000 standard transactions. In
early 2013, this limit had almost been reached and an agreement was reached to increase the
limit. The change was implemented in wallet version 0.8 and ended with a 24-blocks chain split
and a successful double-spend attack [9]. While the bug was not in the Bitcoin protocol, but
rather in the database engine it could have been easily caught by a simple stress test if there was
no artiﬁcially introduced block size limit.

Constants also act as a form of centralization point. Despite the peer-to-peer nature of
Bitcoin, an overwhelming majority of nodes use the oﬃcial reference client [10] developed by
a small group of people. This group makes the decision to implement changes to the protocol
and most people accept these changes irrespective of their “correctness”. Some decisions caused
heated discussions and even calls for boycott [11], which indicates that the community and the
developers may disagree on some important points. It therefore seems logical to have a protocol
with user-conﬁgurable and self-adjusting variables as a possible way to avoid these problems.

2.5 Bulky scripts

The scripting system in Bitcoin is a heavy and complex feature. It potentially allows one to create
sophisticated transactions [12], but some of its features are disabled due to security concerns and
some have never even been used [13]. The script (including both senders’ and receivers’ parts)
for the most popular transaction in Bitcoin looks like this:

<sig> <pubKey> OP DUP OP HASH160 <pubKeyHash> OP EQUALVERIFY OP CHECKSIG.
The script is 164 bytes long whereas its only purpose is to check if the receiver possess the

secret key required to verify his signature.

3 The CryptoNote Technology

Now that we have covered the limitations of the Bitcoin technology, we will concentrate on
presenting the features of CryptoNote.

4 Untraceable Transactions

In this section we propose a scheme of fully anonymous transactions satisfying both untraceability
and unlinkability conditions. An important feature of our solution is its autonomy: the sender
is not required to cooperate with other users or a trusted third party to make his transactions;
hence each participant produces a cover traﬃc independently.

4.1 Literature review

Our scheme relies on the cryptographic primitive called a group signature. First presented by
D. Chaum and E. van Heyst [19], it allows a user to sign his message on behalf of the group.
After signing the message the user provides (for veriﬁcation purposes) not his own single public

1This is so-called “soft limit” — the reference client restriction for creating new blocks. Hard maximum of

possible blocksize was 1 MB

4

key, but the keys of all the users of his group. A veriﬁer is convinced that the real signer is a
member of the group, but cannot exclusively identify the signer.

The original protocol required a trusted third party (called the Group Manager), and he was
the only one who could trace the signer. The next version called a ring signature, introduced
by Rivest et al.
in [34], was an autonomous scheme without Group Manager and anonymity
revocation. Various modiﬁcations of this scheme appeared later: linkable ring signature [26, 27,
17] allowed to determine if two signatures were produced by the same group member, traceable
ring signature [24, 23] limited excessive anonymity by providing possibility to trace the signer of
two messages with respect to the same metainformation (or “tag” in terms of [24]).

A similar cryptographic construction is also known as a ad-hoc group signature [16, 38]. It
emphasizes the arbitrary group formation, whereas group/ring signature schemes rather imply a
ﬁxed set of members.

For the most part, our solution is based on the work “Traceable ring signature” by E. Fujisaki
and K. Suzuki [24]. In order to distinguish the original algorithm and our modiﬁcation we will
call the latter a one-time ring signature, stressing the user’s capability to produce only one valid
signature under his private key. We weakened the traceability property and kept the linkability
only to provide one-timeness: the public key may appear in many foreign verifying sets and the
private key can be used for generating a unique anonymous signature. In case of a double spend
attempt these two signatures will be linked together, but revealing the signer is not necessary
for our purposes.

4.2 Deﬁnitions

4.2.1 Elliptic curve parameters

As our base signature algorithm we chose to use the fast scheme EdDSA, which is developed and
implemented by D.J. Bernstein et al. [18]. Like Bitcoin’s ECDSA it is based on the elliptic curve
discrete logarithm problem, so our scheme could also be applied to Bitcoin in future.

Common parameters are:

q: a prime number; q = 2255 − 19;
d: an element of Fq; d = −121665/121666;
E: an elliptic curve equation; −x2 + y2 = 1 + dx2y2;
G: a base point; G = (x,−4/5);
l: a prime order of the base point; l = 2252 + 27742317777372353535851937790883648493;
Hs: a cryptographic hash function {0, 1}∗ → Fq;
Hp: a deterministic hash function E(Fq) → E(Fq).

4.2.2 Terminology

Enhanced privacy requires a new terminology which should not be confused with Bitcoin entities.
private ec-key is a standard elliptic curve private key: a number a ∈ [1, l − 1];

public ec-key is a standard elliptic curve public key: a point A = aG;

one-time keypair is a pair of private and public ec-keys;

5

private user key is a pair (a, b) of two diﬀerent private ec-keys;
tracking key is a pair (a, B) of private and public ec-key (where B = bG and a (cid:54)= b);

public user key is a pair (A, B) of two public ec-keys derived from (a, b);

standard address is a representation of a public user key given into human friendly string

with error correction;

truncated address is a representation of the second half (point B) of a public user key given

into human friendly string with error correction.

The transaction structure remains similar to the structure in Bitcoin: every user can choose
several independent incoming payments (transactions outputs), sign them with the corresponding
private keys and send them to diﬀerent destinations.

Contrary to Bitcoin’s model, where a user possesses unique private and public key, in the
proposed model a sender generates a one-time public key based on the recipient’s address and
some random data. In this sense, an incoming transaction for the same recipient is sent to a
one-time public key (not directly to a unique address) and only the recipient can recover the
corresponding private part to redeem his funds (using his unique private key). The recipient can
spend the funds using a ring signature, keeping his ownership and actual spending anonymous.
The details of the protocol are explained in the next subsections.

4.3 Unlinkable payments

Classic Bitcoin addresses, once being published, become unambiguous identiﬁer for incoming
payments, linking them together and tying to the recipient’s pseudonyms. If someone wants to
receive an “untied” transaction, he should convey his address to the sender by a private channel.
If he wants to receive diﬀerent transactions which cannot be proven to belong to the same owner
he should generate all the diﬀerent addresses and never publish them in his own pseudonym.

Public

Private

Alice

Carol

Bob’s addr 1

Bob’s key 1

Bob’s addr 2

Bob’s key 2

Bob

Fig. 2. Traditional Bitcoin keys/transactions model.

We propose a solution allowing a user to publish a single address and receive unconditional
unlinkable payments. The destination of each CryptoNote output (by default) is a public key,
derived from recipient’s address and sender’s random data. The main advantage against Bitcoin
is that every destination key is unique by default (unless the sender uses the same data for each
of his transactions to the same recipient). Hence, there is no such issue as “address reuse” by
design and no observer can determine if any transactions were sent to a speciﬁc address or link
two addresses together.

6

Alice

One-time key

Public

Private

One-time key

Bob

Carol

One-time key

Bob’s Address

Bob’s Key

Fig. 3. CryptoNote keys/transactions model.

First, the sender performs a Diﬃe-Hellman exchange to get a shared secret from his data and
half of the recipient’s address. Then he computes a one-time destination key, using the shared
secret and the second half of the address. Two diﬀerent ec-keys are required from the recipient
for these two steps, so a standard CryptoNote address is nearly twice as large as a Bitcoin wallet
address. The receiver also performs a Diﬃe-Hellman exchange to recover the corresponding
secret key.

A standard transaction sequence goes as follows:

1. Alice wants to send a payment to Bob, who has published his standard address. She

unpacks the address and gets Bob’s public key (A, B).

2. Alice generates a random r ∈ [1, l− 1] and computes a one-time public key P = Hs(rA)G +

3. Alice uses P as a destination key for the output and also packs value R = rG (as a part
of the Diﬃe-Hellman exchange) somewhere into the transaction. Note that she can create
other outputs with unique public keys: diﬀerent recipients’ keys (Ai, Bi) imply diﬀerent Pi
even with the same r.

Tx public key

R = rG

r

Sender’s ran-

dom data

P = Hs(rA)G + B

(A, B)

Receiver’s
public key

Fig. 4. Standard transaction structure.

4. Alice sends the transaction.
5. Bob checks every passing transaction with his private key (a, b), and computes P (cid:48) =
If Alice’s transaction for with Bob as the recipient was among them,

Hs(aR)G + B.
then aR = arG = rA and P (cid:48) = P .

7

B.

Transaction

Tx output

Amount

Destination key

6. Bob can recover the corresponding one-time private key: x = Hs(aR) + b, so as P = xG.

He can spend this output at any time by signing a transaction with x.

Receiver’s
private key

(a, b)

one-time private key
x = Hs(aR) + b

Transaction

R

Tx public key

Tx output

one-time public key
P (cid:48) = Hs(aR)G + bG

P (cid:48) ?= P

Amount

Destination key

Fig. 5. Incoming transaction check.

As a result Bob gets incoming payments, associated with one-time public keys which are

unlinkable for a spectator. Some additional notes:

• When Bob “recognizes” his transactions (see step 5) he practically uses only half of his
private information: (a, B). This pair, also known as the tracking key, can be passed
to a third party (Carol). Bob can delegate her the processing of new transactions. Bob
doesn’t need to explicitly trust Carol, because she can’t recover the one-time secret key p
without Bob’s full private key (a, b). This approach is useful when Bob lacks bandwidth
or computation power (smartphones, hardware wallets etc.).

• In case Alice wants to prove she sent a transaction to Bob’s address she can either disclose
r or use any kind of zero-knowledge protocol to prove she knows r (for example by signing
the transaction with r).

• If Bob wants to have an audit compatible address where all incoming transaction are
linkable, he can either publish his tracking key or use a truncated address. That address
represent only one public ec-key B, and the remaining part required by the protocol is
derived from it as follows: a = Hs(B) and A = Hs(B)G. In both cases every person is
able to “recognize” all of Bob’s incoming transaction, but, of course, none can spend the
funds enclosed within them without the secret key b.

4.4 One-time ring signatures

A protocol based on one-time ring signatures allows users to achieve unconditional unlinkability.
Unfortunately, ordinary types of cryptographic signatures permit to trace transactions to their
respective senders and receivers. Our solution to this deﬁciency lies in using a diﬀerent signature
type than those currently used in electronic cash systems.

We will ﬁrst provide a general description of our algorithm with no explicit reference to

electronic cash.

A one-time ring signature contains four algorithms: (GEN, SIG, VER, LNK):

GEN: takes public parameters and outputs an ec-pair (P, x) and a public key I.
SIG: takes a message m, a set S(cid:48) of public keys {Pi}i(cid:54)=s, a pair (Ps, xs) and outputs a signature σ

and a set S = S(cid:48) ∪ {Ps}.

8

VER: takes a message m, a set S, a signature σ and outputs “true” or “false”.
LNK: takes a set I = {Ii}, a signature σ and outputs “linked” or “indep”.

The idea behind the protocol is fairly simple: a user produces a signature which can be
checked by a set of public keys rather than a unique public key. The identity of the signer is
indistinguishable from the other users whose public keys are in the set until the owner produces
a second signature using the same keypair.

Private keys

x0

···

···

xn

sign

Ring

Signature

Public keys

P0

···

···

Pn

verify

Fig. 6. Ring signature anonymity.

GEN: The signer picks a random secret key x ∈ [1, l − 1] and computes the corresponding
public key P = xG. Additionally he computes another public key I = xHp(P ) which we will
call the “key image”.
SIG: The signer generates a one-time ring signature with a non-interactive zero-knowledge
proof using the techniques from [21]. He selects a random subset S(cid:48) of n from the other users’
public keys Pi, his own keypair (x, P ) and key image I. Let 0 ≤ s ≤ n be signer’s secret index
in S (so that his public key is Ps).
He picks a random {qi | i = 0 . . . n} and {wi | i = 0 . . . n, i (cid:54)= s} from (1 . . . l) and applies the

following transformations:

xi

Pi

The next step is getting the non-interactive challenge:

Finally the signer computes the response:

(cid:40)
(cid:40)

Li =

Ri =

qiG,
qiG + wiPi,
qiHp(Pi),
qiHp(Pi) + wiI,

if i = s
if i (cid:54)= s

if i = s
if i (cid:54)= s

c = Hs(m, L1, . . . , Ln, R1, . . . , Rn)

wi,
c − n(cid:80)
(cid:40)

i=0

ci =

ci mod l,

ri =

qi,
qs − csx mod l,

if i (cid:54)= s
if i = s

if i (cid:54)= s
if i = s

The resulting signature is σ = (I, c1, . . . , cn, r1, . . . , rn).

9

VER: The veriﬁer checks the signature by applying the inverse transformations:

(cid:40)

ci

n(cid:80)

i=0

L(cid:48)
i = riG + ciPi
i = riHp(Pi) + ciI
R(cid:48)
?= Hs(m, L(cid:48)
0, . . . , L(cid:48)

Finally, the veriﬁer checks if

n, R(cid:48)

0, . . . , R(cid:48)

n) mod l

If this equality is correct, the veriﬁer runs the algorithm LNK. Otherwise the veriﬁer rejects

the signature.
set I). Multiple uses imply that two signatures were produced under the same secret key.

LNK: The veriﬁer checks if I has been used in past signatures (these values are stored in the

The meaning of the protocol: by applying L-transformations the signer proves that he knows
such x that at least one Pi = xG. To make this proof non-repeatable we introduce the key image
as I = xHp(P ). The signer uses the same coeﬃcients (ri, ci) to prove almost the same statement:
he knows such x that at least one Hp(Pi) = I · x−1.

If the mapping x → I is an injection:

1. Nobody can recover the public key from the key image and identify the signer;

2. The signer cannot make two signatures with diﬀerent I’s and the same x.

A full security analysis is provided in Appendix A.

4.5 Standard CryptoNote transaction

By combining both methods (unlinkable public keys and untraceable ring signature) Bob achieves
new level of privacy in comparison with the original Bitcoin scheme. It requires him to store only
one private key (a, b) and publish (A, B) to start receiving and sending anonymous transactions.
While validating each transaction Bob additionally performs only two elliptic curve multi-
plications and one addition per output to check if a transaction belongs to him. For his every
output Bob recovers a one-time keypair (pi, Pi) and stores it in his wallet. Any inputs can be
circumstantially proved to have the same owner only if they appear in a single transaction. In
fact this relationship is much harder to establish due to the one-time ring signature.

With a ring signature Bob can eﬀectively hide every input among somebody else’s; all possible
spenders will be equiprobable, even the previous owner (Alice) has no more information than
any observer.

When signing his transaction Bob speciﬁes n foreign outputs with the same amount as his
output, mixing all of them without the participation of other users. Bob himself (as well as
anybody else) does not know if any of these payments have been spent: an output can be used
in thousands of signatures as an ambiguity factor and never as a target of hiding. The double
spend check occurs in the LNK phase when checking against the used key images set.

Bob can choose the ambiguity degree on his own: n = 1 means that the probability he has
spent the output is 50% probability, n = 99 gives 1%. The size of the resulting signature increases
linearly as O(n + 1), so the improved anonymity costs to Bob extra transaction fees. He also can
set n = 0 and make his ring signature to consist of only one element, however this will instantly
reveal him as a spender.

10

Output1

Destination key

Outputn

Destination key

Foreign transactions

Transaction

Tx input

Output0

. . .

. . .

Outputi

Outputn

Key image

Signatures

Ring Signature

Sender’s output

Destination key

One-time keypair

One-time
private key

P, x

I = xHp(P )

Fig. 7. Ring signature generation in a standard transaction.

5 Egalitarian Proof-of-work

In this section we propose and ground the new proof-of-work algorithm. Our primary goal
is to close the gap between CPU (majority) and GPU/FPGA/ASIC (minority) miners.
It is
appropriate that some users can have a certain advantage over others, but their investments
should grow at least linearly with the power. More generally, producing special-purpose devices
has to be as less proﬁtable as possible.

5.1 Related works

The original Bitcoin proof-of-work protocol uses the CPU-intensive pricing function SHA-256.
It mainly consists of basic logical operators and relies solely on the computational speed of
processor, therefore is perfectly suitable for multicore/conveyer implementation.

However, modern computers are not limited by the number of operations per second alone,
but also by memory size. While some processors can be substantially faster than others [8],
memory sizes are less likely to vary between machines.

Memory-bound price functions were ﬁrst introduced by Abadi et al and were deﬁned as
“functions whose computation time is dominated by the time spent accessing memory” [15].
The main idea is to construct an algorithm allocating a large block of data (“scratchpad”)
within memory that can be accessed relatively slowly (for example, RAM) and “accessing an
unpredictable sequence of locations” within it. A block should be large enough to make preserving
the data more advantageous than recomputing it for each access. The algorithm also should
prevent internal parallelism, hence N simultaneous threads should require N times more memory
at once.

Dwork et al [22] investigated and formalized this approach leading them to suggest another
variant of the pricing function: “Mbound”. One more work belongs to F. Coelho [20], who

11

proposed the most eﬀective solution: “Hokkaido”.

To our knowledge the last work based on the idea of pseudo-random searches in a big array is
the algorithm known as “scrypt” by C. Percival [32]. Unlike the previous functions it focuses on
key derivation, and not proof-of-work systems. Despite this fact scrypt can serve our purpose:
it works well as a pricing function in the partial hash conversion problem such as SHA-256 in
Bitcoin.

By now scrypt has already been applied in Litecoin [14] and some other Bitcoin forks. How-
ever, its implementation is not really memory-bound: the ratio “memory access time / overall
time” is not large enough because each instance uses only 128 KB. This permits GPU miners
to be roughly 10 times more eﬀective and continues to leave the possibility of creating relatively
cheap but highly-eﬃcient mining devices.

Moreover, the scrypt construction itself allows a linear trade-oﬀ between memory size and
CPU speed due to the fact that every block in the scratchpad is derived only from the previous.
For example, you can store every second block and recalculate the others in a lazy way, i.e. only
when it becomes necessary. The pseudo-random indexes are assumed to be uniformly distributed,
hence the expected value of the additional blocks’ recalculations is 1
of iterations. The overall computation time increases less than by half because there are also
time independent (constant time) operations such as preparing the scratchpad and hashing on
every iteration. Saving 2/3 of the memory costs 1
9/10 results in 1
increases the time less than by a factor of s−1
200 times faster than the modern chips can store only 320 bytes of the scratchpad.

3 · 2 · N = N additional recalculations;
s of all blocks
2 . This in turn implies that a machine with a CPU

10 · 9 · N = 4.5N . It is easy to show that storing only 1

2 · N , where N is the number

10 · N + . . . + 1

3 · N + 1

5.2 The proposed algorithm

We propose a new memory-bound algorithm for the proof-of-work pricing function. It relies on
random access to a slow memory and emphasizes latency dependence. As opposed to scrypt every
new block (64 bytes in length) depends on all the previous blocks. As a result a hypothetical
“memory-saver” should increase his calculation speed exponentially.

Our algorithm requires about 2 Mb per instance for the following reasons:

1. It ﬁts in the L3 cache (per core) of modern processors, which should become mainstream

in a few years;

2. A megabyte of internal memory is an almost unacceptable size for a modern ASIC pipeline;

3. GPUs may run hundreds of concurrent instances, but they are limited in other ways:
GDDR5 memory is slower than the CPU L3 cache and remarkable for its bandwidth, not
random access speed.

4. Signiﬁcant expansion of the scratchpad would require an increase in iterations, which in
turn implies an overall time increase. “Heavy” calls in a trust-less p2p network may lead to
serious vulnerabilities, because nodes are obliged to check every new block’s proof-of-work.
If a node spends a considerable amount of time on each hash evaluation, it can be easily
DDoSed by a ﬂood of fake objects with arbitrary work data (nonce values).

12

6 Further advantages

6.1 Smooth emission
The upper bound for the overall amount of CryptoNote digital coins is: MSupply = 264 − 1
atomic units. This is a natural restriction based only on implementation limits, not on intuition
such as “N coins ought to be enough for anybody”.

To ensure the smoothness of the emission process we use the following formula for block

rewards:

BaseReward = (MSupply − A) (cid:29) 18,

where A is amount of previously generated coins.

6.2 Adjustable parameters

6.2.1 Diﬃculty

CryptoNote contains a targeting algorithm which changes the diﬃculty of every block. This
decreases the system’s reaction time when the network hashrate is intensely growing or shrinking,
preserving a constant block rate. The original Bitcoin method calculates the relation of actual
and target time-span between the last 2016 blocks and uses it as the multiplier for the current
diﬃculty. Obviously this is unsuitable for rapid recalculations (because of large inertia) and
results in oscillations.

The general idea behind our algorithm is to sum all the work completed by the nodes and
divide it by the time they have spent. The measure of work is the corresponding diﬃculty values
in each block. But due to inaccurate and untrusted timestamps we cannot determine the exact
time interval between blocks. A user can shift his timestamp into the future and the next time
intervals might be improbably small or even negative. Presumably there will be few incidents of
this kind, so we can just sort the timestamps and cut-oﬀ the outliers (i.e. 20%). The range of
the rest values is the time which was spent for 80% of the corresponding blocks.

6.2.2 Size limits

Users pay for storing the blockchain and shall be entitled to vote for its size. Every miner
deals with the trade-oﬀ between balancing the costs and proﬁt from the fees and sets his own
“soft-limit” for creating blocks. Also the core rule for the maximum block size is necessary for
preventing the blockchain from being ﬂooded with bogus transaction, however this value should
not be hard-coded.
Let MN be the median value of the last N blocks sizes. Then the “hard-limit” for the size
of accepting blocks is 2 · MN . It averts the blockchain from bloating but still allows the limit to
slowly grow with time if necessary.

Transaction size does not need to be limited explicitly. It is bounded by the size of a block;
and if somebody wants to create a huge transaction with hundreds of inputs/outputs (or with
the high ambiguity degree in ring signatures), he can do so by paying suﬃcient fee.

6.2.3 Excess size penalty

A miner still has the ability to stuﬀ a block full of his own zero-fee transactions up to its maximum
size 2 · Mb. Even though only the majority of miners can shift the median value, there is still a

13

possibility to bloat the blockchain and produce an additional load on the nodes. To discourage
malevolent participants from creating large blocks we introduce a penalty function:

NewReward = BaseReward ·

(cid:18) BlkSize

MN

(cid:19)2

− 1

This rule is applied only when BlkSize is greater than minimal free block size which should
be close to max(10kb, MN · 110%). Miners are permitted to create blocks of “usual size” and even
exceed it with proﬁt when the overall fees surpass the penalty. But fees are unlikely to grow
quadratically unlike the penalty value so there will be an equilibrium.

6.3 Transaction scripts

CryptoNote has a very minimalistic scripting subsystem. A sender speciﬁes an expression Φ =
f (x1, x2, . . . , xn), where n is the number of destination public keys {Pi}n
i=1. Only ﬁve binary
operators are supported: min, max, sum, mul and cmp. When the receiver spends this payment,
he produces 0 ≤ k ≤ n signatures and passes them to transaction input. The veriﬁcation process
simply evaluates Φ with xi = 1 to check for a valid signature for the public key Pi, and xi = 0.
A veriﬁer accepts the proof iﬀ Φ > 0.

Despite its simplicity this approach covers every possible case:
• Multi-/Threshold signature. For the Bitcoin-style “M-out-of-N” multi-signature (i.e.
the receiver should provide at least 0 ≤ M ≤ N valid signatures) Φ = x1+x2+. . .+xN ≥ M
(for clarity we are using common algebraic notation). The weighted threshold signature
(some keys can be more important than other) could be expressed as Φ = w1 · x1 +
w2 · x2 + . . . + wN · xN ≥ wM . And scenario where the master-key corresponds to Φ =
max(M · x, x1 + x2 + . . . + xN ) ≥ M . It is easy to show that any sophisticated case can be
expressed with these operators, i.e. they form basis.

• Password protection. Possession of a secret password s is equivalent to the knowledge of
a private key, deterministically derived from the password: k = KDF(s). Hence, a receiver
can prove that he knows the password by providing another signature under the key k.
The sender simply adds the corresponding public key to his own output. Note that this
method is much more secure than the “transaction puzzle” used in Bitcoin [13], where the
password is explicitly passed in the inputs.

• Degenerate cases. Φ = 1 means that anybody can spend the money; Φ = 0 marks the

output as not spendable forever.

In the case when the output script combined with public keys is too large for a sender, he
can use special output type, which indicates that the recipient will put this data in his input
while the sender provides only a hash of it. This approach is similar to Bitcoin’s “pay-to-hash”
feature, but instead of adding new script commands we handle this case at the data structure
level.

7 Conclusion

We have investigated the major ﬂaws in Bitcoin and proposed some possible solutions. These ad-
vantageous features and our ongoing development make new electronic cash system CryptoNote
a serious rival to Bitcoin, outclassing all its forks.

14

Nobel prize laureate Friedrich Hayek in his famous work proves that the existence of con-
current independent currencies has a huge positive eﬀect. Each currency issuer (or developer in
our case) is trying to attract users by improving his product. Currency is like a commodity: it
can have unique beneﬁts and shortcomings and the most convenient and trusted currency has
the greatest demand. Suppose we had a currency excelling Bitcoin: it means that Bitcoin would
develop faster and become better. The biggest support as an open source project would come
from its own users, who are interested in it.

We do not consider CryptoNote as a full replacement to Bitcoin. On the contrary, having
two (or more) strong and convenient currencies is better than having just one. Running two and
more diﬀerent projects in parallel is the natural ﬂow of electronic cash economics.

15

A Security

We shall give a proof for our one-time ring signature scheme. At some point it coincides with
the parts of the proof in [24], but we decided to rewrite them with a reference rather than to
force a reader to rush about from one paper to another.

These are the properties to be established:
• Linkability. Given all the secret keys {xi}n

i=1 for a set S it is impossible to produce n + 1
valid signatures σ1, σ2, . . . , σn+1, such that all of them pass the LNK phase (i.e. with
n + 1 diﬀerent key images Ii). This property implies the double spending protection in the
context of CryptoNote.

• Exculpability. Given set S, at most n− 1 corresponding private keys xi (excluding i = j)
and the image Ij of the keys xj it is impossible to produce a valid signature σ with Ij.
This property implies theft protection in the context of CryptoNote.

• Unforgeability. Given only a public keys set S it is impossible to produce a valid signature

• Anonymity. Given a signature σ and the corresponding set S it is impossible to determine

the secret index j of the signer with a probability p > 1
n .

σ.

Linkability

Theorem 1. Our one-time ring signature scheme is linkable under the random oracle model.
Proof. Suppose an adversary can produce n + 1 valid signatures σi with key images Ii (cid:54)= Ij
for any i, j ∈ [1 . . . n]. Since #S = n, at least one Ii (cid:54)= xiHp(Pi) for every i. Consider the
corresponding signature σ = (I, c1, . . . , cn, r1, . . . , rn). VER(σ) = “true”, this means that



L(cid:48)
i = riG + ciPi
n(cid:80)
i = riHp(Pi) + ciI
R(cid:48)
ci = Hs(m, L(cid:48)

i=1

1, . . . , L(cid:48)

n, R(cid:48)

1, . . . , R(cid:48)

n) mod l

The ﬁrst two equalities imply(cid:40)

logG L(cid:48)
logHp(Pi) R(cid:48)

i = ri + cixi

i = ri + ci logHp(Pi) I

where logA B informally denotes the discrete logarithm of B to the base A.
As in [24] we note that (cid:64)i : xi = logHp(Pi) I implies that all ci’s are uniquely determined.
The third equality forces the adversary to ﬁnd a pre-image of Hs to succeed in the attack, an
event whose probability is considered to be negligible.

Exculpability

Theorem 2. Our one-time ring signature scheme is exculpable under the discrete logarithm
assumption in the random oracle model.

16

Proof. Suppose an adversary can produce a valid signature σ = (I, c1, . . . , cn, r1, . . . , rn) with
I = xjHP (Pj) with given {xi | i = 1, . . . , j−1, j +1, . . . , n}. Then, we can construct an algorithm
A which solves the discrete logarithm problem in E(Fq).
Suppose inst = (G, P ) ∈ E(Fq) is a given instance of the DLP and the goal is to get s,
such that P = sG. Using the standard technique (as in [24]), A simulates the random and
signing oracles and makes the adversary produce two valid signatures with Pj = P in the set S:
σ = (I, c1, . . . , cn, r1, . . . , rn) and σ(cid:48) = (I, c(cid:48)

1, . . . , r(cid:48)

1, . . . , c(cid:48)

n, r(cid:48)

n).

Since I = xjHp(Pj) in both signatures we compute xj = logHp(Pj ) I =
A outputs xj because Lj = rjG + cjPj = r(cid:48)

jPj and Pj = P .

jG + c(cid:48)

rj−r(cid:48)
j−cj
c(cid:48)

j

mod l

Unforgeability

It has been shown in [24] that unforgeability is just an implication of both linkability and excul-
pability.

Theorem 3. If a one-time ring signature scheme is linkable and exculpable, then it is unforgeable.
Proof. Suppose an adversary can forge a signature for a given set S: σ0 = (I0, . . .). Consider
all valid signatures (produced by the honest signers) for the same message m and the set S:
σ1, σ2, . . . , σn. There are two possible cases:

1. I0 ∈ {Ii}n
2. I0 (cid:54)∈ {Ii}n

i=1. Which contradicts exculpability.

i=1. Which contradicts linkability.

Anonymity

Theorem 4. Our one-time ring signature scheme is anonymous under the decisional Diﬃe-
Hellman assumption in the random oracle model.

2 + (cid:15)
2 .

Proof. Suppose an adversary can determine the secret index j of the Signer with a probability
n + (cid:15). Then, we can construct algorithm A which solves the decisional Diﬃe-Hellman
p = 1
problem in E(Fq) with the probability 1
Let inst = (G1, G2, Q1, Q2) ∈ E(Fq) be the instance of DDH and the goal to determine if
logG1 Q1 = logG2 Q2. A feeds the adversary with valid signature σ0 = (I, . . .), where Pj =
xjG1 = Q1 and I = Q2 and simulates oracle Hp, returning G2 for query Hp(Pj).
If k = j, then A
returns 1 (for “yes”) otherwise a random r ∈ {1, 0}. The probability of the right choice is com-
2 +Pr (k = j | inst ∈ DDH)+
puted as in [24]: 1
Pr (k (cid:54)= j | inst ∈ DDH)·Pr (r = 1)−Pr (k = j | inst /∈ DDH)−Pr (k (cid:54)= j | inst /∈ DDH)·Pr (r = 0) =
n + (cid:15) + ( n−1
2 + 1
In fact, the result should be reduced by the probability of collision in Hs, but this value is

2 +Pr (1 | inst ∈ DDH)−Pr (1 | inst /∈ DDH) = 1
n − (cid:15)) · 1

The adversary returns k as his guess for the index i : I = xiHP (Pi).

n − n−1

n · 1

2 − 1

2 = 1

2 + (cid:15)

1

2

considered to be negligible.

Notes on the hash function Hp
We deﬁned Hp as deterministic hash function E(Fq) → E(Fq). None of the proofs demands Hp
to be an ideal cryptographic hash function. It’s main purpose is to get a pseudo-random base
for image key I = xHp(xG) in some determined way.

With ﬁxed base (I = xG2) the following scenario is possible:

17

1. Alice sends two standard transactions to Bob, generating one-time tx-keys: P2 = Hs(r1A)G+

B and P1 = Hs(r2A)G + B.

2. Bob recovers corresponding one-time private tx-keys x1 and x2 and spends the outputs

with valid signatures and images keys I1 = x1G2 and I2 = x2G2.

3. Now Alice can link these signatures, checking the equality I1−I2

?= (Hs(r1A)−Hs(r2A))G2.
The problem is that Alice knows the linear correlation between public keys P1 and P2 and in
case of ﬁxed base G2 she also gets the same correlation between key images I1 and I2. Replacing
G2 with Hp(xG2), which does not preserve linearity, ﬁxes that ﬂaw.

For constructing deterministic Hp we use algorithm presented in [37].

18

References

[1] http://bitcoin.org.

[2] https://en.bitcoin.it/wiki/Category:Mixing Services.

[3] http://blog.ezyang.com/2012/07/secure-multiparty-bitcoin-anonymization.

[4] https://bitcointalk.org/index.php?topic=279249.0.

[5] http://msrvideo.vo.msecnd.net/rmcvideos/192058/dl/192058.pdf.

[6] https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki#Speciﬁcation.

[7] https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki#Backwards

Compatibility.

[8] https://en.bitcoin.it/wiki/Mining hardware comparison.

[9] https://github.com/bitcoin/bips/blob/master/bip-0050.mediawiki.

[10] http://luke.dashjr.org/programs/bitcoin/ﬁles/charts/branches.html.

[11] https://bitcointalk.org/index.php?topic=196259.0.

[12] https://en.bitcoin.it/wiki/Contracts.

[13] https://en.bitcoin.it/wiki/Script.

[14] http://litecoin.org.

[15] Mart´ın Abadi, Michael Burrows, and Ted Wobber. Moderately hard, memory-bound func-

tions. In NDSS, 2003.

[16] Ben Adida, Susan Hohenberger, and Ronald L. Rivest. Ad-hoc-group signatures from hi-

jacked keypairs. In in DIMACS Workshop on Theft in E-Commerce, 2005.

[17] Man Ho Au, Sherman S. M. Chow, Willy Susilo, and Patrick P. Tsang. Short linkable ring

signatures revisited. In EuroPKI, pages 101–115, 2006.

[18] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. High-speed

high-security signatures. J. Cryptographic Engineering, 2(2):77–89, 2012.

[19] David Chaum and Eug`ene van Heyst. Group signatures. In EUROCRYPT, pages 257–265,

1991.

[20] Fabien Coelho. Exponential memory-bound functions for proof of work protocols. IACR

Cryptology ePrint Archive, 2005:356, 2005.

[21] Ronald Cramer, Ivan Damg˚ard, and Berry Schoenmakers. Proofs of partial knowledge and

simpliﬁed design of witness hiding protocols. In CRYPTO, pages 174–187, 1994.

[22] Cynthia Dwork, Andrew Goldberg, and Moni Naor. On memory-bound functions for ﬁghting

spam. In CRYPTO, pages 426–444, 2003.

[23] Eiichiro Fujisaki. Sub-linear size traceable ring signatures without random oracles. In CT-

RSA, pages 393–415, 2011.

19

[24] Eiichiro Fujisaki and Koutarou Suzuki. Traceable ring signature. In Public Key Cryptogra-

phy, pages 181–200, 2007.

[25] Jezz Garzik. Peer review of “quantitative analysis of the full bitcoin transaction graph”.

https://gist.github.com/3901921, 2012.

[26] Joseph K. Liu, Victor K. Wei, and Duncan S. Wong. Linkable spontaneous anonymous

group signature for ad hoc groups (extended abstract). In ACISP, pages 325–335, 2004.

[27] Joseph K. Liu and Duncan S. Wong. Linkable ring signatures: Security models and new

schemes. In ICCSA (2), pages 614–623, 2005.

[28] Ian Miers, Christina Garman, Matthew Green, and Aviel D. Rubin. Zerocoin: Anonymous
distributed e-cash from bitcoin. In IEEE Symposium on Security and Privacy, pages 397–
411, 2013.

[29] Micha Ober, Stefan Katzenbeisser, and Kay Hamacher. Structure and anonymity of the

bitcoin transaction graph. Future internet, 5(2):237–250, 2013.

[30] Tatsuaki Okamoto and Kazuo Ohta. Universal electronic cash. In CRYPTO, pages 324–337,

1991.

[31] Marc Santamaria Ortega. The bitcoin transaction graph — anonymity. Master’s thesis,

Universitat Oberta de Catalunya, June 2013.

[32] Colin Percival. Stronger key derivation via sequential memory-hard functions. Presented at

BSDCan’09, May 2009.

abs/1107.4524, 2011.

pages 552–565, 2001.

[33] Fergal Reid and Martin Harrigan. An analysis of anonymity in the bitcoin system. CoRR,

[34] Ronald L. Rivest, Adi Shamir, and Yael Tauman. How to leak a secret. In ASIACRYPT,

[35] Dorit Ron and Adi Shamir. Quantitative analysis of the full bitcoin transaction graph.

IACR Cryptology ePrint Archive, 2012:584, 2012.

[36] Meni Rosenfeld. Analysis of hashrate-based double-spending. 2012.

[37] Maciej Ulas. Rational points on certain hyperelliptic curves over ﬁnite ﬁelds. Bulletin of

the Polish Academy of Sciences. Mathematics, 55(2):97–104, 2007.

[38] Qianhong Wu, Willy Susilo, Yi Mu, and Fangguo Zhang. Ad hoc group signatures.

In

IWSEC, pages 120–135, 2006.

20

